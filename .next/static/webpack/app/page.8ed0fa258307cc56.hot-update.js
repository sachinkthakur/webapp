"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/geo-location.ts":
/*!**************************************!*\
  !*** ./src/services/geo-location.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeolocationError: function() { return /* binding */ GeolocationError; },\n/* harmony export */   getAddressFromCoordinates: function() { return /* binding */ getAddressFromCoordinates; },\n/* harmony export */   getCurrentPosition: function() { return /* binding */ getCurrentPosition; }\n/* harmony export */ });\n/**\n * Custom Error class for Geolocation errors.\n */ class GeolocationError extends Error {\n    constructor(message, code){\n        super(message);\n        this.name = \"GeolocationError\";\n        this.code = code;\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, GeolocationError.prototype);\n    }\n}\n/**\n * Gets the current geographical coordinates of the device.\n * @returns A promise that resolves with the GeolocationCoordinates object or rejects with a GeolocationError.\n */ const getCurrentPosition = ()=>{\n    return new Promise((resolve, reject)=>{\n        if (!navigator.geolocation) {\n            reject(new GeolocationError(\"Geolocation is not supported by this browser.\", -1)); // Use a custom code for non-support\n            return;\n        }\n        navigator.geolocation.getCurrentPosition((position)=>{\n            resolve(position.coords);\n        }, (error)=>{\n            let message = \"\";\n            switch(error.code){\n                case error.PERMISSION_DENIED:\n                    message = \"User denied the request for Geolocation.\";\n                    break;\n                case error.POSITION_UNAVAILABLE:\n                    message = \"Location information is unavailable. Check GPS signal and network connection.\";\n                    break;\n                case error.TIMEOUT:\n                    message = \"Could not get location in time. Check GPS signal and network connection, then try again.\";\n                    break;\n                default:\n                    message = \"An unknown error occurred while retrieving location.\";\n                    break;\n            }\n            reject(new GeolocationError(\"\".concat(message, \" (Code: \").concat(error.code, \")\"), error.code));\n        }, {\n            enableHighAccuracy: true,\n            timeout: 20000,\n            maximumAge: 0\n        });\n    });\n};\n/**\n * Reverse geocodes latitude and longitude to get an address.\n * Uses the OpenStreetMap Nominatim API.\n * @param latitude The latitude coordinate.\n * @param longitude The longitude coordinate.\n * @returns A promise that resolves with the address string or rejects with an error.\n */ const getAddressFromCoordinates = async (latitude, longitude)=>{\n    console.log(\"[GeoService] Fetching address for Lat: \".concat(latitude, \", Lon: \").concat(longitude));\n    try {\n        // IMPORTANT: As per Nominatim's usage policy, a valid User-Agent is required.\n        // Replace 'YourAppName/1.0 (your-contact-email@example.com)' with your actual app name and a contact email.\n        const response = await fetch(\"https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=\".concat(latitude, \"&lon=\").concat(longitude), {\n            headers: {\n                \"User-Agent\": \"FieldTrackApp/1.0 (contact@ewheelslogistics.com)\" // Example User-Agent\n            }\n        });\n        if (!response.ok) {\n            const errorText = await response.text().catch(()=>\"Could not read error response body.\");\n            console.error(\"[GeoService] Nominatim API request failed. Status: \".concat(response.status, \". Response: \").concat(errorText));\n            throw new Error(\"Address lookup failed: Server responded with status \".concat(response.status, \".\"));\n        }\n        const data = await response.json();\n        if (data && data.display_name) {\n            console.log(\"[GeoService] Address found: \".concat(data.display_name));\n            return data.display_name;\n        } else {\n            console.warn(\"[GeoService] Nominatim response did not contain display_name or data was unexpected:\", data);\n            throw new Error(\"Address data not found in API response. The location might be in an area with no known address (e.g., open water).\");\n        }\n    } catch (error) {\n        console.error(\"[GeoService] Error in getAddressFromCoordinates:\", error);\n        if (error.message && (error.message.startsWith(\"Address lookup failed:\") || error.message.startsWith(\"Address data not found\"))) {\n            throw error; // Re-throw specific, informative errors\n        }\n        // Fallback for network errors or other unexpected issues\n        throw new Error(\"Could not retrieve address. Please check your network connection and try refreshing the location.\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9nZW8tbG9jYXRpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0NBRUMsR0FDTSxNQUFNQSx5QkFBeUJDO0lBR3BDQyxZQUFZQyxPQUFlLEVBQUVDLElBQVksQ0FBRTtRQUN6QyxLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixnQ0FBZ0M7UUFDaENFLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVQLGlCQUFpQlEsU0FBUztJQUN4RDtBQUNGO0FBRUE7OztDQUdDLEdBQ00sTUFBTUMscUJBQXFCO0lBQ2hDLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUMzQixJQUFJLENBQUNDLFVBQVVDLFdBQVcsRUFBRTtZQUMxQkYsT0FBTyxJQUFJWixpQkFBaUIsaURBQWlELENBQUMsS0FBSyxvQ0FBb0M7WUFDdkg7UUFDRjtRQUVBYSxVQUFVQyxXQUFXLENBQUNMLGtCQUFrQixDQUN0QyxDQUFDTTtZQUNDSixRQUFRSSxTQUFTQyxNQUFNO1FBQ3pCLEdBQ0EsQ0FBQ0M7WUFDQyxJQUFJZCxVQUFVO1lBQ2QsT0FBUWMsTUFBTWIsSUFBSTtnQkFDaEIsS0FBS2EsTUFBTUMsaUJBQWlCO29CQUMxQmYsVUFBVTtvQkFDVjtnQkFDRixLQUFLYyxNQUFNRSxvQkFBb0I7b0JBQzdCaEIsVUFBVTtvQkFDVjtnQkFDRixLQUFLYyxNQUFNRyxPQUFPO29CQUNmakIsVUFBVTtvQkFDWDtnQkFDRjtvQkFDRUEsVUFBVTtvQkFDVjtZQUNKO1lBQ0FTLE9BQU8sSUFBSVosaUJBQWlCLEdBQXFCaUIsT0FBbEJkLFNBQVEsWUFBcUIsT0FBWGMsTUFBTWIsSUFBSSxFQUFDLE1BQUlhLE1BQU1iLElBQUk7UUFDNUUsR0FDQTtZQUNFaUIsb0JBQW9CO1lBQ3BCQyxTQUFTO1lBQ1RDLFlBQVk7UUFDZDtJQUVKO0FBQ0YsRUFBRTtBQUVGOzs7Ozs7Q0FNQyxHQUNNLE1BQU1DLDRCQUE0QixPQUFPQyxVQUFrQkM7SUFDaEVDLFFBQVFDLEdBQUcsQ0FBQywwQ0FBNERGLE9BQWxCRCxVQUFTLFdBQW1CLE9BQVZDO0lBQ3hFLElBQUk7UUFDRiw4RUFBOEU7UUFDOUUsNEdBQTRHO1FBQzVHLE1BQU1HLFdBQVcsTUFBTUMsTUFBTSxpRUFBaUZKLE9BQWhCRCxVQUFTLFNBQWlCLE9BQVZDLFlBQWE7WUFDekhLLFNBQVM7Z0JBQ1AsY0FBYyxtREFBbUQscUJBQXFCO1lBQ3hGO1FBQ0Y7UUFFQSxJQUFJLENBQUNGLFNBQVNHLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1KLFNBQVNLLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07WUFDcERSLFFBQVFWLEtBQUssQ0FBQyxzREFBb0ZnQixPQUE5QkosU0FBU08sTUFBTSxFQUFDLGdCQUF3QixPQUFWSDtZQUNsRyxNQUFNLElBQUloQyxNQUFNLHVEQUF1RSxPQUFoQjRCLFNBQVNPLE1BQU0sRUFBQztRQUN6RjtRQUVBLE1BQU1DLE9BQU8sTUFBTVIsU0FBU1MsSUFBSTtRQUVoQyxJQUFJRCxRQUFRQSxLQUFLRSxZQUFZLEVBQUU7WUFDN0JaLFFBQVFDLEdBQUcsQ0FBQywrQkFBaUQsT0FBbEJTLEtBQUtFLFlBQVk7WUFDNUQsT0FBT0YsS0FBS0UsWUFBWTtRQUMxQixPQUFPO1lBQ0xaLFFBQVFhLElBQUksQ0FBQyx3RkFBd0ZIO1lBQ3JHLE1BQU0sSUFBSXBDLE1BQU07UUFDbEI7SUFDRixFQUFFLE9BQU9nQixPQUFZO1FBQ25CVSxRQUFRVixLQUFLLENBQUMsb0RBQW9EQTtRQUNsRSxJQUFJQSxNQUFNZCxPQUFPLElBQUtjLENBQUFBLE1BQU1kLE9BQU8sQ0FBQ3NDLFVBQVUsQ0FBQyw2QkFBNkJ4QixNQUFNZCxPQUFPLENBQUNzQyxVQUFVLENBQUMseUJBQXdCLEdBQUk7WUFDN0gsTUFBTXhCLE9BQU8sd0NBQXdDO1FBQ3pEO1FBQ0EseURBQXlEO1FBQ3pELE1BQU0sSUFBSWhCLE1BQU07SUFDbEI7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9nZW8tbG9jYXRpb24udHM/ZmE2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBmb3IgR2VvbG9jYXRpb24gZXJyb3JzLlxuICovXG5leHBvcnQgY2xhc3MgR2VvbG9jYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29kZTogbnVtYmVyKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0dlb2xvY2F0aW9uRXJyb3InO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgZXhwbGljaXRseS5cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgR2VvbG9jYXRpb25FcnJvci5wcm90b3R5cGUpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGRldmljZS5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEdlb2xvY2F0aW9uQ29vcmRpbmF0ZXMgb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBhIEdlb2xvY2F0aW9uRXJyb3IuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50UG9zaXRpb24gPSAoKTogUHJvbWlzZTxHZW9sb2NhdGlvbkNvb3JkaW5hdGVzPiA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgICAgIHJlamVjdChuZXcgR2VvbG9jYXRpb25FcnJvcignR2VvbG9jYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuJywgLTEpKTsgLy8gVXNlIGEgY3VzdG9tIGNvZGUgZm9yIG5vbi1zdXBwb3J0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgIChwb3NpdGlvbikgPT4ge1xuICAgICAgICByZXNvbHZlKHBvc2l0aW9uLmNvb3Jkcyk7XG4gICAgICB9LFxuICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgIGNhc2UgZXJyb3IuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gJ1VzZXIgZGVuaWVkIHRoZSByZXF1ZXN0IGZvciBHZW9sb2NhdGlvbi4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBlcnJvci5QT1NJVElPTl9VTkFWQUlMQUJMRTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTG9jYXRpb24gaW5mb3JtYXRpb24gaXMgdW5hdmFpbGFibGUuIENoZWNrIEdQUyBzaWduYWwgYW5kIG5ldHdvcmsgY29ubmVjdGlvbi4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBlcnJvci5USU1FT1VUOlxuICAgICAgICAgICAgIG1lc3NhZ2UgPSAnQ291bGQgbm90IGdldCBsb2NhdGlvbiBpbiB0aW1lLiBDaGVjayBHUFMgc2lnbmFsIGFuZCBuZXR3b3JrIGNvbm5lY3Rpb24sIHRoZW4gdHJ5IGFnYWluLic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgbG9jYXRpb24uJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChuZXcgR2VvbG9jYXRpb25FcnJvcihgJHttZXNzYWdlfSAoQ29kZTogJHtlcnJvci5jb2RlfSlgLCBlcnJvci5jb2RlKSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWUsXG4gICAgICAgIHRpbWVvdXQ6IDIwMDAwLCAvLyBJbmNyZWFzZWQgdGltZW91dCB0byAyMCBzZWNvbmRzXG4gICAgICAgIG1heGltdW1BZ2U6IDAsXG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldmVyc2UgZ2VvY29kZXMgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSB0byBnZXQgYW4gYWRkcmVzcy5cbiAqIFVzZXMgdGhlIE9wZW5TdHJlZXRNYXAgTm9taW5hdGltIEFQSS5cbiAqIEBwYXJhbSBsYXRpdHVkZSBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSBsb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBjb29yZGluYXRlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYWRkcmVzcyBzdHJpbmcgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICovXG5leHBvcnQgY29uc3QgZ2V0QWRkcmVzc0Zyb21Db29yZGluYXRlcyA9IGFzeW5jIChsYXRpdHVkZTogbnVtYmVyLCBsb25naXR1ZGU6IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGNvbnNvbGUubG9nKGBbR2VvU2VydmljZV0gRmV0Y2hpbmcgYWRkcmVzcyBmb3IgTGF0OiAke2xhdGl0dWRlfSwgTG9uOiAke2xvbmdpdHVkZX1gKTtcbiAgdHJ5IHtcbiAgICAvLyBJTVBPUlRBTlQ6IEFzIHBlciBOb21pbmF0aW0ncyB1c2FnZSBwb2xpY3ksIGEgdmFsaWQgVXNlci1BZ2VudCBpcyByZXF1aXJlZC5cbiAgICAvLyBSZXBsYWNlICdZb3VyQXBwTmFtZS8xLjAgKHlvdXItY29udGFjdC1lbWFpbEBleGFtcGxlLmNvbSknIHdpdGggeW91ciBhY3R1YWwgYXBwIG5hbWUgYW5kIGEgY29udGFjdCBlbWFpbC5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL25vbWluYXRpbS5vcGVuc3RyZWV0bWFwLm9yZy9yZXZlcnNlP2Zvcm1hdD1qc29udjImbGF0PSR7bGF0aXR1ZGV9Jmxvbj0ke2xvbmdpdHVkZX1gLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdVc2VyLUFnZW50JzogJ0ZpZWxkVHJhY2tBcHAvMS4wIChjb250YWN0QGV3aGVlbHNsb2dpc3RpY3MuY29tKScgLy8gRXhhbXBsZSBVc2VyLUFnZW50XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gJ0NvdWxkIG5vdCByZWFkIGVycm9yIHJlc3BvbnNlIGJvZHkuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKGBbR2VvU2VydmljZV0gTm9taW5hdGltIEFQSSByZXF1ZXN0IGZhaWxlZC4gU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30uIFJlc3BvbnNlOiAke2Vycm9yVGV4dH1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyBsb29rdXAgZmFpbGVkOiBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfS5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5kaXNwbGF5X25hbWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbR2VvU2VydmljZV0gQWRkcmVzcyBmb3VuZDogJHtkYXRhLmRpc3BsYXlfbmFtZX1gKTtcbiAgICAgIHJldHVybiBkYXRhLmRpc3BsYXlfbmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdbR2VvU2VydmljZV0gTm9taW5hdGltIHJlc3BvbnNlIGRpZCBub3QgY29udGFpbiBkaXNwbGF5X25hbWUgb3IgZGF0YSB3YXMgdW5leHBlY3RlZDonLCBkYXRhKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWRkcmVzcyBkYXRhIG5vdCBmb3VuZCBpbiBBUEkgcmVzcG9uc2UuIFRoZSBsb2NhdGlvbiBtaWdodCBiZSBpbiBhbiBhcmVhIHdpdGggbm8ga25vd24gYWRkcmVzcyAoZS5nLiwgb3BlbiB3YXRlcikuJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcIltHZW9TZXJ2aWNlXSBFcnJvciBpbiBnZXRBZGRyZXNzRnJvbUNvb3JkaW5hdGVzOlwiLCBlcnJvcik7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnQWRkcmVzcyBsb29rdXAgZmFpbGVkOicpIHx8IGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnQWRkcmVzcyBkYXRhIG5vdCBmb3VuZCcpKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgc3BlY2lmaWMsIGluZm9ybWF0aXZlIGVycm9yc1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3IgbmV0d29yayBlcnJvcnMgb3Igb3RoZXIgdW5leHBlY3RlZCBpc3N1ZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmV0cmlldmUgYWRkcmVzcy4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBjb25uZWN0aW9uIGFuZCB0cnkgcmVmcmVzaGluZyB0aGUgbG9jYXRpb24uXCIpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbIkdlb2xvY2F0aW9uRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNvZGUiLCJuYW1lIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJnZXRDdXJyZW50UG9zaXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5hdmlnYXRvciIsImdlb2xvY2F0aW9uIiwicG9zaXRpb24iLCJjb29yZHMiLCJlcnJvciIsIlBFUk1JU1NJT05fREVOSUVEIiwiUE9TSVRJT05fVU5BVkFJTEFCTEUiLCJUSU1FT1VUIiwiZW5hYmxlSGlnaEFjY3VyYWN5IiwidGltZW91dCIsIm1heGltdW1BZ2UiLCJnZXRBZGRyZXNzRnJvbUNvb3JkaW5hdGVzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJjYXRjaCIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwiZGlzcGxheV9uYW1lIiwid2FybiIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/geo-location.ts\n"));

/***/ })

});