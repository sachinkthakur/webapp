"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/services/attendance.ts":
/*!************************************!*\
  !*** ./src/services/attendance.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEmployee: function() { return /* binding */ addEmployee; },\n/* harmony export */   deleteEmployee: function() { return /* binding */ deleteEmployee; },\n/* harmony export */   generateAttendanceCsv: function() { return /* binding */ generateAttendanceCsv; },\n/* harmony export */   getAttendanceRecords: function() { return /* binding */ getAttendanceRecords; },\n/* harmony export */   getEmployeeById: function() { return /* binding */ getEmployeeById; },\n/* harmony export */   getEmployees: function() { return /* binding */ getEmployees; },\n/* harmony export */   saveAttendance: function() { return /* binding */ saveAttendance; },\n/* harmony export */   updateEmployee: function() { return /* binding */ updateEmployee; }\n/* harmony export */ });\n// In a real application, you would replace localStorage with API calls to your backend.\n// For demonstration purposes, we'll use localStorage.\n// NOTE: Functions using localStorage are inherently client-side dependent.\n// Define the structure of an Employee\n// --- Employee Management ---\n/**\n * Fetches all registered employees from localStorage.\n * Handles potential errors during access or parsing.\n */ const getEmployees = async ()=>{\n    console.log(\"Fetching employees from localStorage\");\n    if (false) {}\n    try {\n        const employeesJson = localStorage.getItem(\"employees\");\n        return employeesJson ? JSON.parse(employeesJson) : [];\n    } catch (error) {\n        console.error(\"Error fetching or parsing employees from localStorage:\", error);\n        // Optionally clear corrupted data: localStorage.removeItem('employees');\n        return []; // Return empty array on error\n    }\n};\n/**\n * Adds a new employee to localStorage.\n * Returns the added employee (potentially with a server-assigned ID).\n */ const addEmployee = async (employeeData)=>{\n    if (false) {}\n    console.log(\"Adding employee to localStorage:\", employeeData);\n    const employees = await getEmployees();\n    // Basic validation (add more robust validation as needed)\n    if (!employeeData.employeeId || !employeeData.name || !employeeData.phone) {\n        throw new Error(\"Employee ID, Name, and Phone Number are required.\");\n    }\n    if (employees.some((emp)=>emp.employeeId === employeeData.employeeId)) {\n        throw new Error('Employee ID \"'.concat(employeeData.employeeId, '\" already exists.'));\n    }\n    if (employees.some((emp)=>emp.phone === employeeData.phone)) {\n        throw new Error('Phone number \"'.concat(employeeData.phone, '\" is already registered.'));\n    }\n    // Assign a simple unique ID for localStorage demo\n    const newEmployee = {\n        ...employeeData,\n        id: \"emp_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 8))\n    }; // Added randomness\n    try {\n        employees.push(newEmployee);\n        localStorage.setItem(\"employees\", JSON.stringify(employees));\n        console.log(\"Employee added:\", newEmployee);\n        return newEmployee;\n    } catch (error) {\n        console.error(\"Error saving employees to localStorage:\", error);\n        throw new Error(\"Failed to save employee data.\"); // Rethrow or handle appropriately\n    }\n};\n/**\n * Updates an existing employee in localStorage.\n */ const updateEmployee = async (updatedEmployeeData)=>{\n    if (false) {}\n    console.log(\"Updating employee in localStorage:\", updatedEmployeeData);\n    let employees = await getEmployees();\n    // Basic validation\n    if (!updatedEmployeeData.id) {\n        throw new Error(\"Employee ID (internal) is required for updates.\");\n    }\n    if (!updatedEmployeeData.employeeId || !updatedEmployeeData.name || !updatedEmployeeData.phone) {\n        throw new Error(\"Employee ID, Name, and Phone Number are required.\");\n    }\n    // Check for conflicts (excluding the current employee being updated)\n    if (employees.some((emp)=>emp.employeeId === updatedEmployeeData.employeeId && emp.id !== updatedEmployeeData.id)) {\n        throw new Error('Employee ID \"'.concat(updatedEmployeeData.employeeId, '\" already exists.'));\n    }\n    if (employees.some((emp)=>emp.phone === updatedEmployeeData.phone && emp.id !== updatedEmployeeData.id)) {\n        throw new Error('Phone number \"'.concat(updatedEmployeeData.phone, '\" is already registered.'));\n    }\n    const employeeIndex = employees.findIndex((emp)=>emp.id === updatedEmployeeData.id);\n    if (employeeIndex === -1) {\n        throw new Error('Employee with internal ID \"'.concat(updatedEmployeeData.id, '\" not found.'));\n    }\n    try {\n        employees[employeeIndex] = updatedEmployeeData;\n        localStorage.setItem(\"employees\", JSON.stringify(employees));\n        console.log(\"Employee updated:\", updatedEmployeeData);\n        return updatedEmployeeData;\n    } catch (error) {\n        console.error(\"Error saving updated employees to localStorage:\", error);\n        throw new Error(\"Failed to update employee data.\"); // Rethrow or handle appropriately\n    }\n};\n/**\n * Deletes an employee from localStorage.\n */ const deleteEmployee = async (employeeInternalId)=>{\n    if (false) {}\n    console.log(\"Deleting employee from localStorage, ID:\", employeeInternalId);\n    let employees = await getEmployees();\n    const initialLength = employees.length;\n    employees = employees.filter((emp)=>emp.id !== employeeInternalId);\n    if (employees.length === initialLength) {\n        console.warn('Employee with internal ID \"'.concat(employeeInternalId, '\" not found for deletion.'));\n    // Depending on requirements, you might throw an error or just log a warning\n    // throw new Error(`Employee with internal ID \"${employeeInternalId}\" not found.`);\n    } else {\n        try {\n            localStorage.setItem(\"employees\", JSON.stringify(employees));\n            console.log(\"Employee deleted successfully.\");\n        // Optional: Delete associated attendance records (ensure this is also client-side safe)\n        // await deleteAttendanceRecordsForEmployee(employeeId); // Implement this if needed\n        } catch (error) {\n            console.error(\"Error saving employees after deletion to localStorage:\", error);\n            throw new Error(\"Failed to update employee list after deletion.\"); // Rethrow or handle appropriately\n        }\n    }\n};\n/**\n * Fetches a single employee by their user ID (phone or employeeId) from localStorage.\n * Needed for the attendance page to get employee details.\n */ const getEmployeeById = async (userId)=>{\n    console.log(\"Fetching employee data for ID/Phone: \".concat(userId));\n    if (false) {}\n    try {\n        const employees = await getEmployees();\n        const employee = employees.find((emp)=>emp.phone === userId || emp.employeeId === userId);\n        return employee || null;\n    } catch (error) {\n        console.error(\"Error fetching employee by ID:\", error);\n        return null;\n    }\n};\n// --- Attendance Management ---\n/**\n * Fetches all attendance records from localStorage, optionally filtered by date range.\n * Handles potential errors during access or parsing.\n */ const getAttendanceRecords = async (startDate, endDate)=>{\n    console.log(\"Fetching attendance records from localStorage. Dates: \".concat(startDate === null || startDate === void 0 ? void 0 : startDate.toISOString(), \" to \").concat(endDate === null || endDate === void 0 ? void 0 : endDate.toISOString()));\n    if (false) {}\n    let records = [];\n    try {\n        const recordsJson = localStorage.getItem(\"attendanceRecords\");\n        if (recordsJson) {\n            // Safely parse and ensure timestamp is a Date object\n            const parsedData = JSON.parse(recordsJson);\n            if (Array.isArray(parsedData)) {\n                records = parsedData.map((record)=>({\n                        ...record,\n                        // Ensure timestamp exists and is valid before creating Date\n                        timestamp: record.timestamp ? new Date(record.timestamp) : new Date(0),\n                        inTime: record.inTime ? new Date(record.inTime) : undefined,\n                        outTime: record.outTime ? new Date(record.outTime) : undefined\n                    })).filter((record)=>!isNaN(record.timestamp.getTime())); // Filter out records with invalid dates\n            } else {\n                console.warn(\"Attendance records in localStorage are not an array. Resetting.\");\n                localStorage.removeItem(\"attendanceRecords\");\n            }\n        }\n    } catch (error) {\n        console.error(\"Error fetching or parsing attendance records from localStorage:\", error);\n        // Optionally clear corrupted data: localStorage.removeItem('attendanceRecords');\n        return []; // Return empty array on error\n    }\n    // Filter by date range if provided\n    if (startDate || endDate) {\n        records = records.filter((record)=>{\n            if (!(record.timestamp instanceof Date) || isNaN(record.timestamp.getTime())) {\n                return false; // Skip records with invalid timestamps\n            }\n            const recordDate = record.timestamp;\n            // Set time to 00:00:00 for start date comparison\n            const start = startDate ? new Date(startDate.setHours(0, 0, 0, 0)) : null;\n            // Set time to 23:59:59 for end date comparison\n            const end = endDate ? new Date(endDate.setHours(23, 59, 59, 999)) : null;\n            const isAfterStart = start ? recordDate >= start : true;\n            const isBeforeEnd = end ? recordDate <= end : true;\n            // console.log(`Record ${record.id} timestamp: ${recordDate.toISOString()}, Start: ${start?.toISOString()}, End: ${end?.toISOString()}, Filter Result: ${isAfterStart && isBeforeEnd}`);\n            return isAfterStart && isBeforeEnd;\n        });\n    }\n    // Sort by timestamp, most recent first (descending)\n    records.sort((a, b)=>{\n        const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : 0;\n        const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : 0;\n        return timeB - timeA;\n    });\n    // console.log(`Filtered and sorted records count: ${records.length}`);\n    return records;\n};\n/**\n * Saves a new attendance record to localStorage.\n * Handles IN/OUT time logic.\n */ const saveAttendance = async (record)=>{\n    if (false) {}\n    console.log(\"Saving attendance record to localStorage (data):\", {\n        ...record,\n        photoDataUri: \"omitted for brevity\"\n    });\n    const allRecords = await getAttendanceRecords(); // Get all records first\n    // Assign a simple unique ID for localStorage demo\n    const newRecord = {\n        ...record,\n        id: \"att_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 8)),\n        timestamp: new Date(record.timestamp)\n    };\n    // --- IN/OUT Time Logic ---\n    const todayStart = new Date(newRecord.timestamp);\n    todayStart.setHours(0, 0, 0, 0);\n    const todayEnd = new Date(todayStart);\n    todayEnd.setDate(todayStart.getDate() + 1);\n    // Find records for the same employee on the same calendar day\n    const todaysEmployeeRecords = allRecords.filter((r)=>r.employeeId === newRecord.employeeId && r.timestamp >= todayStart && r.timestamp < todayEnd).sort((a, b)=>a.timestamp.getTime() - b.timestamp.getTime()); // Sort oldest first\n    if (todaysEmployeeRecords.length === 0) {\n        // This is the first record of the day for this employee\n        newRecord.inTime = newRecord.timestamp;\n        newRecord.outTime = undefined; // Explicitly set outTime to undefined\n        console.log(\"Setting IN time for \".concat(newRecord.employeeId, \" on \").concat(todayStart.toDateString(), \": \").concat(newRecord.inTime.toLocaleTimeString()));\n    } else {\n        // This is a subsequent record for the day\n        // Use the IN time from the earliest record of the day\n        newRecord.inTime = todaysEmployeeRecords[0].inTime || todaysEmployeeRecords[0].timestamp; // Fallback to timestamp if inTime missing\n        // This new record becomes the latest OUT time for the day so far\n        newRecord.outTime = newRecord.timestamp;\n        console.log(\"Setting OUT time for \".concat(newRecord.employeeId, \" on \").concat(todayStart.toDateString(), \": \").concat(newRecord.outTime.toLocaleTimeString(), \" (In: \").concat(newRecord.inTime.toLocaleTimeString(), \")\"));\n        // --- Crucially, update the outTime on *previous* records for this day ---\n        // This ensures the Admin view shows the correct latest outTime for the day on all records of that day\n        todaysEmployeeRecords.forEach((existingRecord)=>{\n            if (existingRecord.id) {\n                const index = allRecords.findIndex((r)=>r.id === existingRecord.id);\n                if (index !== -1) {\n                    allRecords[index].outTime = newRecord.outTime; // Update the outTime\n                    allRecords[index].inTime = newRecord.inTime; // Also update inTime for consistency on older records\n                // console.log(`Updating existing record ${allRecords[index].id} with Out: ${newRecord.outTime.toLocaleTimeString()}, In: ${newRecord.inTime.toLocaleTimeString()}`);\n                }\n            }\n        });\n    }\n    // --- End IN/OUT Logic ---\n    // Add the *new* record to the main list\n    allRecords.unshift(newRecord); // Add to the beginning\n    // Filter out any potentially duplicated records before saving (just in case)\n    const uniqueRecords = Array.from(new Map(allRecords.map((item)=>[\n            item.id,\n            item\n        ])).values());\n    // Sort again before saving to maintain order (optional, but good practice)\n    uniqueRecords.sort((a, b)=>b.timestamp.getTime() - a.timestamp.getTime());\n    try {\n        localStorage.setItem(\"attendanceRecords\", JSON.stringify(uniqueRecords));\n        console.log(\"Attendance record saved: \".concat(newRecord.id, \", Total records now: \").concat(uniqueRecords.length));\n        return newRecord; // Return the newly created record with potentially added in/out times\n    } catch (error) {\n        console.error(\"Error saving attendance records to localStorage:\", error);\n        throw new Error(\"Failed to save attendance data.\"); // Rethrow or handle appropriately\n    }\n};\n// --- Utility Functions (Example) ---\n/**\n * Generates a CSV string from attendance records.\n */ const generateAttendanceCsv = (records)=>{\n    console.log(\"Generating CSV for \".concat(records.length, \" records.\"));\n    if (!records || records.length === 0) {\n        return \"\";\n    }\n    // Define headers carefully - match the order in the rows\n    const headers = [\n        \"Employee ID\",\n        \"Phone Number\",\n        \"Name\",\n        \"Date\",\n        \"Marked Time\",\n        \"In Time\",\n        \"Out Time\",\n        \"Shift Timing\",\n        \"Working Location\",\n        \"Latitude\",\n        \"Longitude\",\n        \"Address\",\n        \"Capture Method\"\n    ];\n    // Function to format date/time, handling undefined or invalid dates\n    const formatDateTime = (date, type)=>{\n        if (!date) return \"--\";\n        const d = date instanceof Date ? date : new Date(date); // Ensure it's a Date object\n        if (isNaN(d.getTime())) return \"Invalid Date\"; // Check if the date is valid\n        try {\n            if (type === \"date\") return d.toLocaleDateString();\n            if (type === \"time\") return d.toLocaleTimeString();\n            return \"--\";\n        } catch (e) {\n            console.error(\"Error formatting date:\", d, e);\n            return \"Format Error\";\n        }\n    };\n    // Helper to escape CSV fields containing commas or double quotes\n    const escapeCsvField = (field)=>{\n        if (field === undefined || field === null) return '\"\"';\n        const stringField = String(field);\n        // If the field contains a comma, double quote, or newline, enclose in double quotes and escape existing double quotes\n        if (stringField.includes(\",\") || stringField.includes('\"') || stringField.includes(\"\\n\")) {\n            return '\"'.concat(stringField.replace(/\"/g, '\"\"'), '\"');\n        }\n        return stringField; // Return as is if no special characters\n    };\n    const csvRows = [\n        headers.join(\",\"),\n        ...records.map((record)=>{\n            var _record_latitude, _record_longitude;\n            return [\n                escapeCsvField(record.employeeId),\n                escapeCsvField(record.phone),\n                escapeCsvField(record.name),\n                formatDateTime(record.timestamp, \"date\"),\n                formatDateTime(record.timestamp, \"time\"),\n                formatDateTime(record.inTime, \"time\"),\n                formatDateTime(record.outTime, \"time\"),\n                escapeCsvField(record.shiftTiming),\n                escapeCsvField(record.workingLocation),\n                escapeCsvField((_record_latitude = record.latitude) === null || _record_latitude === void 0 ? void 0 : _record_latitude.toFixed(6)),\n                escapeCsvField((_record_longitude = record.longitude) === null || _record_longitude === void 0 ? void 0 : _record_longitude.toFixed(6)),\n                escapeCsvField(record.address),\n                escapeCsvField(record.captureMethod)\n            ].join(\",\");\n        }) // Join values into a CSV row\n    ];\n    return csvRows.join(\"\\n\"); // Join rows with newline characters\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hdHRlbmRhbmNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsd0ZBQXdGO0FBQ3hGLHNEQUFzRDtBQUN0RCwyRUFBMkU7QUFFM0Usc0NBQXNDO0FBOEJ0Qyw4QkFBOEI7QUFFOUI7OztDQUdDLEdBQ00sTUFBTUEsZUFBZTtJQUMxQkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1osSUFBSSxLQUFrQixFQUFhLEVBR2xDO0lBQ0QsSUFBSTtRQUNGLE1BQU1FLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLE9BQU9GLGdCQUFnQkcsS0FBS0MsS0FBSyxDQUFDSixpQkFBaUIsRUFBRTtJQUN2RCxFQUFFLE9BQU9LLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLDBEQUEwREE7UUFDeEUseUVBQXlFO1FBQ3pFLE9BQU8sRUFBRSxFQUFFLDhCQUE4QjtJQUMzQztBQUNGLEVBQUU7QUFFRjs7O0NBR0MsR0FDTSxNQUFNQyxjQUFjLE9BQU9DO0lBQzlCLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUNEVixRQUFRQyxHQUFHLENBQUMsb0NBQW9DUztJQUNoRCxNQUFNRSxZQUFZLE1BQU1iO0lBRXhCLDBEQUEwRDtJQUMxRCxJQUFJLENBQUNXLGFBQWFHLFVBQVUsSUFBSSxDQUFDSCxhQUFhSSxJQUFJLElBQUksQ0FBQ0osYUFBYUssS0FBSyxFQUFFO1FBQ3ZFLE1BQU0sSUFBSUosTUFBTTtJQUNwQjtJQUNDLElBQUlDLFVBQVVJLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUosVUFBVSxLQUFLSCxhQUFhRyxVQUFVLEdBQUc7UUFDckUsTUFBTSxJQUFJRixNQUFNLGdCQUF3QyxPQUF4QkQsYUFBYUcsVUFBVSxFQUFDO0lBQzFEO0lBQ0QsSUFBSUQsVUFBVUksSUFBSSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJRixLQUFLLEtBQUtMLGFBQWFLLEtBQUssR0FBRztRQUN6RCxNQUFNLElBQUlKLE1BQU0s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T0FBTyxJQUFvQyxPQUFoQ0YsWUFBWUcsT0FBTyxDQUFDLE1BQU0sT0FBTTtRQUMvQztRQUNBLE9BQU9ILGFBQWEsd0NBQXdDO0lBQ2hFO0lBR0YsTUFBTUksVUFBVTtRQUNkYixRQUFRYyxJQUFJLENBQUM7V0FDVjdELFFBQVFLLEdBQUcsQ0FBQ0MsQ0FBQUE7Z0JBVUVBLGtCQUNBQTttQkFYUTtnQkFDdkJnRCxlQUFlaEQsT0FBT3ZDLFVBQVU7Z0JBQ2hDdUYsZUFBZWhELE9BQU9yQyxLQUFLO2dCQUMzQnFGLGVBQWVoRCxPQUFPdEMsSUFBSTtnQkFDMUJnRixlQUFlMUMsT0FBT0MsU0FBUyxFQUFFO2dCQUNqQ3lDLGVBQWUxQyxPQUFPQyxTQUFTLEVBQUU7Z0JBQ2pDeUMsZUFBZTFDLE9BQU9FLE1BQU0sRUFBRTtnQkFDOUJ3QyxlQUFlMUMsT0FBT0ksT0FBTyxFQUFFO2dCQUMvQjRDLGVBQWVoRCxPQUFPd0QsV0FBVztnQkFDakNSLGVBQWVoRCxPQUFPeUQsZUFBZTtnQkFDckNULGdCQUFlaEQsbUJBQUFBLE9BQU8wRCxRQUFRLGNBQWYxRCx1Q0FBQUEsaUJBQWlCMkQsT0FBTyxDQUFDO2dCQUN4Q1gsZ0JBQWVoRCxvQkFBQUEsT0FBTzRELFNBQVMsY0FBaEI1RCx3Q0FBQUEsa0JBQWtCMkQsT0FBTyxDQUFDO2dCQUN6Q1gsZUFBZWhELE9BQU82RCxPQUFPO2dCQUM3QmIsZUFBZWhELE9BQU84RCxhQUFhO2FBQ3BDLENBQUNQLElBQUksQ0FBQztXQUFNLDZCQUE2QjtLQUMzQztJQUVELE9BQU9ELFFBQVFDLElBQUksQ0FBQyxPQUFPLG9DQUFvQztBQUNqRSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9hdHRlbmRhbmNlLnRzP2JmZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW4gYSByZWFsIGFwcGxpY2F0aW9uLCB5b3Ugd291bGQgcmVwbGFjZSBsb2NhbFN0b3JhZ2Ugd2l0aCBBUEkgY2FsbHMgdG8geW91ciBiYWNrZW5kLlxuLy8gRm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXMsIHdlJ2xsIHVzZSBsb2NhbFN0b3JhZ2UuXG4vLyBOT1RFOiBGdW5jdGlvbnMgdXNpbmcgbG9jYWxTdG9yYWdlIGFyZSBpbmhlcmVudGx5IGNsaWVudC1zaWRlIGRlcGVuZGVudC5cblxuLy8gRGVmaW5lIHRoZSBzdHJ1Y3R1cmUgb2YgYW4gRW1wbG95ZWVcbmV4cG9ydCBpbnRlcmZhY2UgRW1wbG95ZWUge1xuICBpZDogc3RyaW5nOyAvLyBVbmlxdWUgaWRlbnRpZmllciAoY291bGQgYmUgVVVJRCBnZW5lcmF0ZWQgb24gY3JlYXRpb24pXG4gIGVtcGxveWVlSWQ6IHN0cmluZzsgLy8gVGhlIElEIGFzc2lnbmVkIGJ5IHRoZSBjb21wYW55XG4gIG5hbWU6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZzsgLy8gU2hvdWxkIGJlIHVuaXF1ZSBmb3IgbG9naW4vaWRlbnRpZmljYXRpb25cbiAgc2hpZnRUaW1pbmc6IHN0cmluZzsgLy8gZS5nLiwgXCI5IEFNIC0gNSBQTVwiXG4gIHdvcmtpbmdMb2NhdGlvbjogc3RyaW5nOyAvLyBlLmcuLCBcIk5vcnRoIFpvbmVcIiwgXCJTaXRlIEFcIlxuICAvLyBBZGQgb3RoZXIgcmVsZXZhbnQgZW1wbG95ZWUgZGV0YWlscyBoZXJlXG59XG5cbi8vIERlZmluZSB0aGUgc3RydWN0dXJlIGZvciBhbiBhdHRlbmRhbmNlIHJlY29yZFxuZXhwb3J0IGludGVyZmFjZSBBdHRlbmRhbmNlUmVjb3JkIHtcbiAgaWQ/OiBzdHJpbmc7IC8vIE9wdGlvbmFsOiBDb3VsZCBiZSBhc3NpZ25lZCBieSB0aGUgYmFja2VuZC9kYXRhYmFzZVxuICBlbXBsb3llZUlkOiBzdHJpbmc7IC8vIExpbmsgdG8gdGhlIEVtcGxveWVlXG4gIHBob25lOiBzdHJpbmc7IC8vIFN0b3JlIHBob25lIGZvciBlYXNpZXIgbG9va3VwL2Rpc3BsYXlcbiAgbmFtZTogc3RyaW5nOyAvLyBTdG9yZSBuYW1lIGZvciBlYXNpZXIgZGlzcGxheVxuICB0aW1lc3RhbXA6IERhdGU7XG4gIGxhdGl0dWRlOiBudW1iZXI7XG4gIGxvbmdpdHVkZTogbnVtYmVyO1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHBob3RvRGF0YVVyaTogc3RyaW5nOyAvLyBTZWxmaWUgcGhvdG8gYXMgYmFzZTY0IGRhdGEgVVJJXG4gIGNhcHR1cmVNZXRob2Q6ICdhdXRvJyB8ICdtYW51YWwnOyAvLyBIb3cgdGhlIGF0dGVuZGFuY2Ugd2FzIG1hcmtlZFxuICBzaGlmdFRpbWluZzogc3RyaW5nOyAvLyBSZWNvcmQgc2hpZnQgYXQgdGltZSBvZiBhdHRlbmRhbmNlXG4gIHdvcmtpbmdMb2NhdGlvbjogc3RyaW5nOyAvLyBSZWNvcmQgbG9jYXRpb24gYXQgdGltZSBvZiBhdHRlbmRhbmNlXG4gIGlzTGF0ZT86IGJvb2xlYW47IC8vIE9wdGlvbmFsOiBDYWxjdWxhdGVkIGJhc2VkIG9uIHNoaWZ0IHRpbWluZ1xuICBpblRpbWU/OiBEYXRlOyAvLyBGaXJzdCByZWNvcmQgb2YgdGhlIGRheSBmb3IgdGhpcyBlbXBsb3llZVxuICBvdXRUaW1lPzogRGF0ZTsgLy8gTGFzdCByZWNvcmQgb2YgdGhlIGRheSBmb3IgdGhpcyBlbXBsb3llZSAodXBkYXRlZCBvbiBzdWJzZXF1ZW50IG1hcmtzKVxufVxuXG4vLyAtLS0gRW1wbG95ZWUgTWFuYWdlbWVudCAtLS1cblxuLyoqXG4gKiBGZXRjaGVzIGFsbCByZWdpc3RlcmVkIGVtcGxveWVlcyBmcm9tIGxvY2FsU3RvcmFnZS5cbiAqIEhhbmRsZXMgcG90ZW50aWFsIGVycm9ycyBkdXJpbmcgYWNjZXNzIG9yIHBhcnNpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbXBsb3llZXMgPSBhc3luYyAoKTogUHJvbWlzZTxFbXBsb3llZVtdPiA9PiB7XG4gIGNvbnNvbGUubG9nKFwiRmV0Y2hpbmcgZW1wbG95ZWVzIGZyb20gbG9jYWxTdG9yYWdlXCIpO1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oXCJsb2NhbFN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyLiBDYW5ub3QgZ2V0IGVtcGxveWVlcy5cIik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZW1wbG95ZWVzSnNvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbXBsb3llZXMnKTtcbiAgICByZXR1cm4gZW1wbG95ZWVzSnNvbiA/IEpTT04ucGFyc2UoZW1wbG95ZWVzSnNvbikgOiBbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgb3IgcGFyc2luZyBlbXBsb3llZXMgZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAvLyBPcHRpb25hbGx5IGNsZWFyIGNvcnJ1cHRlZCBkYXRhOiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZW1wbG95ZWVzJyk7XG4gICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgb24gZXJyb3JcbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgbmV3IGVtcGxveWVlIHRvIGxvY2FsU3RvcmFnZS5cbiAqIFJldHVybnMgdGhlIGFkZGVkIGVtcGxveWVlIChwb3RlbnRpYWxseSB3aXRoIGEgc2VydmVyLWFzc2lnbmVkIElEKS5cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEVtcGxveWVlID0gYXN5bmMgKGVtcGxveWVlRGF0YTogT21pdDxFbXBsb3llZSwgJ2lkJz4pOiBQcm9taXNlPEVtcGxveWVlPiA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgZW1wbG95ZWU6IGxvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIuXCIpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIkFkZGluZyBlbXBsb3llZSB0byBsb2NhbFN0b3JhZ2U6XCIsIGVtcGxveWVlRGF0YSk7XG4gICAgY29uc3QgZW1wbG95ZWVzID0gYXdhaXQgZ2V0RW1wbG95ZWVzKCk7XG5cbiAgICAvLyBCYXNpYyB2YWxpZGF0aW9uIChhZGQgbW9yZSByb2J1c3QgdmFsaWRhdGlvbiBhcyBuZWVkZWQpXG4gICAgaWYgKCFlbXBsb3llZURhdGEuZW1wbG95ZWVJZCB8fCAhZW1wbG95ZWVEYXRhLm5hbWUgfHwgIWVtcGxveWVlRGF0YS5waG9uZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXBsb3llZSBJRCwgTmFtZSwgYW5kIFBob25lIE51bWJlciBhcmUgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICAgaWYgKGVtcGxveWVlcy5zb21lKGVtcCA9PiBlbXAuZW1wbG95ZWVJZCA9PT0gZW1wbG95ZWVEYXRhLmVtcGxveWVlSWQpKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXBsb3llZSBJRCBcIiR7ZW1wbG95ZWVEYXRhLmVtcGxveWVlSWR9XCIgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgIH1cbiAgICBpZiAoZW1wbG95ZWVzLnNvbWUoZW1wID0+IGVtcC5waG9uZSA9PT0gZW1wbG95ZWVEYXRhLnBob25lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBob25lIG51bWJlciBcIiR7ZW1wbG95ZWVEYXRhLnBob25lfVwiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5gKTtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ24gYSBzaW1wbGUgdW5pcXVlIElEIGZvciBsb2NhbFN0b3JhZ2UgZGVtb1xuICAgIGNvbnN0IG5ld0VtcGxveWVlOiBFbXBsb3llZSA9IHsgLi4uZW1wbG95ZWVEYXRhLCBpZDogYGVtcF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpfWAgfTsgLy8gQWRkZWQgcmFuZG9tbmVzc1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZW1wbG95ZWVzLnB1c2gobmV3RW1wbG95ZWUpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZW1wbG95ZWVzJywgSlNPTi5zdHJpbmdpZnkoZW1wbG95ZWVzKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRW1wbG95ZWUgYWRkZWQ6XCIsIG5ld0VtcGxveWVlKTtcbiAgICAgICAgcmV0dXJuIG5ld0VtcGxveWVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIGVtcGxveWVlcyB0byBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYXZlIGVtcGxveWVlIGRhdGEuXCIpOyAvLyBSZXRocm93IG9yIGhhbmRsZSBhcHByb3ByaWF0ZWx5XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGVtcGxveWVlIGluIGxvY2FsU3RvcmFnZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUVtcGxveWVlID0gYXN5bmMgKHVwZGF0ZWRFbXBsb3llZURhdGE6IEVtcGxveWVlKTogUHJvbWlzZTxFbXBsb3llZT4gPT4ge1xuICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgZW1wbG95ZWU6IGxvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIuXCIpO1xuICAgICB9XG4gICAgY29uc29sZS5sb2coXCJVcGRhdGluZyBlbXBsb3llZSBpbiBsb2NhbFN0b3JhZ2U6XCIsIHVwZGF0ZWRFbXBsb3llZURhdGEpO1xuICAgIGxldCBlbXBsb3llZXMgPSBhd2FpdCBnZXRFbXBsb3llZXMoKTtcblxuICAgICAvLyBCYXNpYyB2YWxpZGF0aW9uXG4gICAgIGlmICghdXBkYXRlZEVtcGxveWVlRGF0YS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXBsb3llZSBJRCAoaW50ZXJuYWwpIGlzIHJlcXVpcmVkIGZvciB1cGRhdGVzLlwiKTtcbiAgICAgfVxuICAgIGlmICghdXBkYXRlZEVtcGxveWVlRGF0YS5lbXBsb3llZUlkIHx8ICF1cGRhdGVkRW1wbG95ZWVEYXRhLm5hbWUgfHwgIXVwZGF0ZWRFbXBsb3llZURhdGEucGhvbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wbG95ZWUgSUQsIE5hbWUsIGFuZCBQaG9uZSBOdW1iZXIgYXJlIHJlcXVpcmVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29uZmxpY3RzIChleGNsdWRpbmcgdGhlIGN1cnJlbnQgZW1wbG95ZWUgYmVpbmcgdXBkYXRlZClcbiAgICBpZiAoZW1wbG95ZWVzLnNvbWUoZW1wID0+IGVtcC5lbXBsb3llZUlkID09PSB1cGRhdGVkRW1wbG95ZWVEYXRhLmVtcGxveWVlSWQgJiYgZW1wLmlkICE9PSB1cGRhdGVkRW1wbG95ZWVEYXRhLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtcGxveWVlIElEIFwiJHt1cGRhdGVkRW1wbG95ZWVEYXRhLmVtcGxveWVlSWR9XCIgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgfVxuICAgIGlmIChlbXBsb3llZXMuc29tZShlbXAgPT4gZW1wLnBob25lID09PSB1cGRhdGVkRW1wbG95ZWVEYXRhLnBob25lICYmIGVtcC5pZCAhPT0gdXBkYXRlZEVtcGxveWVlRGF0YS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQaG9uZSBudW1iZXIgXCIke3VwZGF0ZWRFbXBsb3llZURhdGEucGhvbmV9XCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGVtcGxveWVlSW5kZXggPSBlbXBsb3llZXMuZmluZEluZGV4KGVtcCA9PiBlbXAuaWQgPT09IHVwZGF0ZWRFbXBsb3llZURhdGEuaWQpO1xuXG4gICAgaWYgKGVtcGxveWVlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW1wbG95ZWUgd2l0aCBpbnRlcm5hbCBJRCBcIiR7dXBkYXRlZEVtcGxveWVlRGF0YS5pZH1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgZW1wbG95ZWVzW2VtcGxveWVlSW5kZXhdID0gdXBkYXRlZEVtcGxveWVlRGF0YTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtcGxveWVlcycsIEpTT04uc3RyaW5naWZ5KGVtcGxveWVlcykpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVtcGxveWVlIHVwZGF0ZWQ6XCIsIHVwZGF0ZWRFbXBsb3llZURhdGEpO1xuICAgICAgICByZXR1cm4gdXBkYXRlZEVtcGxveWVlRGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHVwZGF0ZWQgZW1wbG95ZWVzIHRvIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIGVtcGxveWVlIGRhdGEuXCIpOyAvLyBSZXRocm93IG9yIGhhbmRsZSBhcHByb3ByaWF0ZWx5XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWxldGVzIGFuIGVtcGxveWVlIGZyb20gbG9jYWxTdG9yYWdlLlxuICovXG5leHBvcnQgY29uc3QgZGVsZXRlRW1wbG95ZWUgPSBhc3luYyAoZW1wbG95ZWVJbnRlcm5hbElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IGRlbGV0ZSBlbXBsb3llZTogbG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlci5cIik7XG4gICAgICByZXR1cm47IC8vIE9yIHRocm93IGVycm9yIGRlcGVuZGluZyBvbiByZXF1aXJlbWVudHNcbiAgIH1cbiAgY29uc29sZS5sb2coXCJEZWxldGluZyBlbXBsb3llZSBmcm9tIGxvY2FsU3RvcmFnZSwgSUQ6XCIsIGVtcGxveWVlSW50ZXJuYWxJZCk7XG4gIGxldCBlbXBsb3llZXMgPSBhd2FpdCBnZXRFbXBsb3llZXMoKTtcbiAgY29uc3QgaW5pdGlhbExlbmd0aCA9IGVtcGxveWVlcy5sZW5ndGg7XG4gIGVtcGxveWVlcyA9IGVtcGxveWVlcy5maWx0ZXIoZW1wID0+IGVtcC5pZCAhPT0gZW1wbG95ZWVJbnRlcm5hbElkKTtcblxuICBpZiAoZW1wbG95ZWVzLmxlbmd0aCA9PT0gaW5pdGlhbExlbmd0aCkge1xuICAgICBjb25zb2xlLndhcm4oYEVtcGxveWVlIHdpdGggaW50ZXJuYWwgSUQgXCIke2VtcGxveWVlSW50ZXJuYWxJZH1cIiBub3QgZm91bmQgZm9yIGRlbGV0aW9uLmApO1xuICAgICAvLyBEZXBlbmRpbmcgb24gcmVxdWlyZW1lbnRzLCB5b3UgbWlnaHQgdGhyb3cgYW4gZXJyb3Igb3IganVzdCBsb2cgYSB3YXJuaW5nXG4gICAgIC8vIHRocm93IG5ldyBFcnJvcihgRW1wbG95ZWUgd2l0aCBpbnRlcm5hbCBJRCBcIiR7ZW1wbG95ZWVJbnRlcm5hbElkfVwiIG5vdCBmb3VuZC5gKTtcbiAgfSBlbHNlIHtcbiAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2VtcGxveWVlcycsIEpTT04uc3RyaW5naWZ5KGVtcGxveWVlcykpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVtcGxveWVlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5LlwiKTtcbiAgICAgICAgIC8vIE9wdGlvbmFsOiBEZWxldGUgYXNzb2NpYXRlZCBhdHRlbmRhbmNlIHJlY29yZHMgKGVuc3VyZSB0aGlzIGlzIGFsc28gY2xpZW50LXNpZGUgc2FmZSlcbiAgICAgICAgIC8vIGF3YWl0IGRlbGV0ZUF0dGVuZGFuY2VSZWNvcmRzRm9yRW1wbG95ZWUoZW1wbG95ZWVJZCk7IC8vIEltcGxlbWVudCB0aGlzIGlmIG5lZWRlZFxuICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIGVtcGxveWVlcyBhZnRlciBkZWxldGlvbiB0byBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBlbXBsb3llZSBsaXN0IGFmdGVyIGRlbGV0aW9uLlwiKTsgLy8gUmV0aHJvdyBvciBoYW5kbGUgYXBwcm9wcmlhdGVseVxuICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRmV0Y2hlcyBhIHNpbmdsZSBlbXBsb3llZSBieSB0aGVpciB1c2VyIElEIChwaG9uZSBvciBlbXBsb3llZUlkKSBmcm9tIGxvY2FsU3RvcmFnZS5cbiAqIE5lZWRlZCBmb3IgdGhlIGF0dGVuZGFuY2UgcGFnZSB0byBnZXQgZW1wbG95ZWUgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVtcGxveWVlQnlJZCA9IGFzeW5jICh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8RW1wbG95ZWUgfCBudWxsPiA9PiB7XG4gIGNvbnNvbGUubG9nKGBGZXRjaGluZyBlbXBsb3llZSBkYXRhIGZvciBJRC9QaG9uZTogJHt1c2VySWR9YCk7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlci4gQ2Fubm90IGdldCBlbXBsb3llZSBieSBJRC5cIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGVtcGxveWVlcyA9IGF3YWl0IGdldEVtcGxveWVlcygpO1xuICAgIGNvbnN0IGVtcGxveWVlID0gZW1wbG95ZWVzLmZpbmQoZW1wID0+IGVtcC5waG9uZSA9PT0gdXNlcklkIHx8IGVtcC5lbXBsb3llZUlkID09PSB1c2VySWQpO1xuICAgIHJldHVybiBlbXBsb3llZSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBlbXBsb3llZSBieSBJRDpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8vIC0tLSBBdHRlbmRhbmNlIE1hbmFnZW1lbnQgLS0tXG5cbi8qKlxuICogRmV0Y2hlcyBhbGwgYXR0ZW5kYW5jZSByZWNvcmRzIGZyb20gbG9jYWxTdG9yYWdlLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGRhdGUgcmFuZ2UuXG4gKiBIYW5kbGVzIHBvdGVudGlhbCBlcnJvcnMgZHVyaW5nIGFjY2VzcyBvciBwYXJzaW5nLlxuICovXG5leHBvcnQgY29uc3QgZ2V0QXR0ZW5kYW5jZVJlY29yZHMgPSBhc3luYyAoc3RhcnREYXRlPzogRGF0ZSwgZW5kRGF0ZT86IERhdGUpOiBQcm9taXNlPEF0dGVuZGFuY2VSZWNvcmRbXT4gPT4ge1xuICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgYXR0ZW5kYW5jZSByZWNvcmRzIGZyb20gbG9jYWxTdG9yYWdlLiBEYXRlczogJHtzdGFydERhdGU/LnRvSVNPU3RyaW5nKCl9IHRvICR7ZW5kRGF0ZT8udG9JU09TdHJpbmcoKX1gKTtcbiAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlci4gQ2Fubm90IGdldCBhdHRlbmRhbmNlIHJlY29yZHMuXCIpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgfVxuXG4gIGxldCByZWNvcmRzOiBBdHRlbmRhbmNlUmVjb3JkW10gPSBbXTtcbiAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlY29yZHNKc29uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F0dGVuZGFuY2VSZWNvcmRzJyk7XG4gICAgICBpZiAocmVjb3Jkc0pzb24pIHtcbiAgICAgICAgLy8gU2FmZWx5IHBhcnNlIGFuZCBlbnN1cmUgdGltZXN0YW1wIGlzIGEgRGF0ZSBvYmplY3RcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UocmVjb3Jkc0pzb24pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWREYXRhKSkge1xuICAgICAgICAgICAgcmVjb3JkcyA9IHBhcnNlZERhdGEubWFwKHJlY29yZCA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnJlY29yZCxcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGltZXN0YW1wIGV4aXN0cyBhbmQgaXMgdmFsaWQgYmVmb3JlIGNyZWF0aW5nIERhdGVcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHJlY29yZC50aW1lc3RhbXAgPyBuZXcgRGF0ZShyZWNvcmQudGltZXN0YW1wKSA6IG5ldyBEYXRlKDApLCAvLyBEZWZhdWx0IHRvIGVwb2NoIGlmIGludmFsaWQvbWlzc2luZ1xuICAgICAgICAgICAgICAgIGluVGltZTogcmVjb3JkLmluVGltZSA/IG5ldyBEYXRlKHJlY29yZC5pblRpbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG91dFRpbWU6IHJlY29yZC5vdXRUaW1lID8gbmV3IERhdGUocmVjb3JkLm91dFRpbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSkpLmZpbHRlcihyZWNvcmQgPT4gIWlzTmFOKHJlY29yZC50aW1lc3RhbXAuZ2V0VGltZSgpKSk7IC8vIEZpbHRlciBvdXQgcmVjb3JkcyB3aXRoIGludmFsaWQgZGF0ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBdHRlbmRhbmNlIHJlY29yZHMgaW4gbG9jYWxTdG9yYWdlIGFyZSBub3QgYW4gYXJyYXkuIFJlc2V0dGluZy5cIik7XG4gICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F0dGVuZGFuY2VSZWNvcmRzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBvciBwYXJzaW5nIGF0dGVuZGFuY2UgcmVjb3JkcyBmcm9tIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgICAgLy8gT3B0aW9uYWxseSBjbGVhciBjb3JydXB0ZWQgZGF0YTogbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F0dGVuZGFuY2VSZWNvcmRzJyk7XG4gICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvclxuICB9XG5cblxuICAvLyBGaWx0ZXIgYnkgZGF0ZSByYW5nZSBpZiBwcm92aWRlZFxuICBpZiAoc3RhcnREYXRlIHx8IGVuZERhdGUpIHtcbiAgICByZWNvcmRzID0gcmVjb3Jkcy5maWx0ZXIocmVjb3JkID0+IHtcbiAgICAgICBpZiAoIShyZWNvcmQudGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkgfHwgaXNOYU4ocmVjb3JkLnRpbWVzdGFtcC5nZXRUaW1lKCkpKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFNraXAgcmVjb3JkcyB3aXRoIGludmFsaWQgdGltZXN0YW1wc1xuICAgICAgIH1cbiAgICAgICBjb25zdCByZWNvcmREYXRlID0gcmVjb3JkLnRpbWVzdGFtcDtcbiAgICAgICAvLyBTZXQgdGltZSB0byAwMDowMDowMCBmb3Igc3RhcnQgZGF0ZSBjb21wYXJpc29uXG4gICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydERhdGUgPyBuZXcgRGF0ZShzdGFydERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCkpIDogbnVsbDtcbiAgICAgICAvLyBTZXQgdGltZSB0byAyMzo1OTo1OSBmb3IgZW5kIGRhdGUgY29tcGFyaXNvblxuICAgICAgIGNvbnN0IGVuZCA9IGVuZERhdGUgPyBuZXcgRGF0ZShlbmREYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSkpIDogbnVsbDtcblxuICAgICAgY29uc3QgaXNBZnRlclN0YXJ0ID0gc3RhcnQgPyByZWNvcmREYXRlID49IHN0YXJ0IDogdHJ1ZTtcbiAgICAgIGNvbnN0IGlzQmVmb3JlRW5kID0gZW5kID8gcmVjb3JkRGF0ZSA8PSBlbmQgOiB0cnVlO1xuICAgICAgLy8gY29uc29sZS5sb2coYFJlY29yZCAke3JlY29yZC5pZH0gdGltZXN0YW1wOiAke3JlY29yZERhdGUudG9JU09TdHJpbmcoKX0sIFN0YXJ0OiAke3N0YXJ0Py50b0lTT1N0cmluZygpfSwgRW5kOiAke2VuZD8udG9JU09TdHJpbmcoKX0sIEZpbHRlciBSZXN1bHQ6ICR7aXNBZnRlclN0YXJ0ICYmIGlzQmVmb3JlRW5kfWApO1xuICAgICAgcmV0dXJuIGlzQWZ0ZXJTdGFydCAmJiBpc0JlZm9yZUVuZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFNvcnQgYnkgdGltZXN0YW1wLCBtb3N0IHJlY2VudCBmaXJzdCAoZGVzY2VuZGluZylcbiAgcmVjb3Jkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgIGNvbnN0IHRpbWVBID0gYS50aW1lc3RhbXAgaW5zdGFuY2VvZiBEYXRlID8gYS50aW1lc3RhbXAuZ2V0VGltZSgpIDogMDtcbiAgICAgY29uc3QgdGltZUIgPSBiLnRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUgPyBiLnRpbWVzdGFtcC5nZXRUaW1lKCkgOiAwO1xuICAgICByZXR1cm4gdGltZUIgLSB0aW1lQTtcbiAgfSk7XG5cbiAgLy8gY29uc29sZS5sb2coYEZpbHRlcmVkIGFuZCBzb3J0ZWQgcmVjb3JkcyBjb3VudDogJHtyZWNvcmRzLmxlbmd0aH1gKTtcbiAgcmV0dXJuIHJlY29yZHM7XG59O1xuXG4vKipcbiAqIFNhdmVzIGEgbmV3IGF0dGVuZGFuY2UgcmVjb3JkIHRvIGxvY2FsU3RvcmFnZS5cbiAqIEhhbmRsZXMgSU4vT1VUIHRpbWUgbG9naWMuXG4gKi9cbmV4cG9ydCBjb25zdCBzYXZlQXR0ZW5kYW5jZSA9IGFzeW5jIChyZWNvcmQ6IE9taXQ8QXR0ZW5kYW5jZVJlY29yZCwgJ2lkJz4pOiBQcm9taXNlPEF0dGVuZGFuY2VSZWNvcmQ+ID0+IHtcbiAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2F2ZSBhdHRlbmRhbmNlOiBsb2NhbFN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyLlwiKTtcbiAgIH1cbiAgY29uc29sZS5sb2coXCJTYXZpbmcgYXR0ZW5kYW5jZSByZWNvcmQgdG8gbG9jYWxTdG9yYWdlIChkYXRhKTpcIiwgeyAuLi5yZWNvcmQsIHBob3RvRGF0YVVyaTogJ29taXR0ZWQgZm9yIGJyZXZpdHknIH0pO1xuICBjb25zdCBhbGxSZWNvcmRzID0gYXdhaXQgZ2V0QXR0ZW5kYW5jZVJlY29yZHMoKTsgLy8gR2V0IGFsbCByZWNvcmRzIGZpcnN0XG5cbiAgLy8gQXNzaWduIGEgc2ltcGxlIHVuaXF1ZSBJRCBmb3IgbG9jYWxTdG9yYWdlIGRlbW9cbiAgY29uc3QgbmV3UmVjb3JkOiBBdHRlbmRhbmNlUmVjb3JkID0ge1xuICAgICAuLi5yZWNvcmQsXG4gICAgIGlkOiBgYXR0XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCl9YCwgLy8gQWRkZWQgcmFuZG9tbmVzc1xuICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHJlY29yZC50aW1lc3RhbXApLCAvLyBFbnN1cmUgaXQncyBhIERhdGUgb2JqZWN0XG4gICB9O1xuXG5cbiAgLy8gLS0tIElOL09VVCBUaW1lIExvZ2ljIC0tLVxuICBjb25zdCB0b2RheVN0YXJ0ID0gbmV3IERhdGUobmV3UmVjb3JkLnRpbWVzdGFtcCk7XG4gIHRvZGF5U3RhcnQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHRvZGF5RW5kID0gbmV3IERhdGUodG9kYXlTdGFydCk7XG4gIHRvZGF5RW5kLnNldERhdGUodG9kYXlTdGFydC5nZXREYXRlKCkgKyAxKTtcblxuICAvLyBGaW5kIHJlY29yZHMgZm9yIHRoZSBzYW1lIGVtcGxveWVlIG9uIHRoZSBzYW1lIGNhbGVuZGFyIGRheVxuICBjb25zdCB0b2RheXNFbXBsb3llZVJlY29yZHMgPSBhbGxSZWNvcmRzXG4gICAgLmZpbHRlcihyID0+XG4gICAgICAgIHIuZW1wbG95ZWVJZCA9PT0gbmV3UmVjb3JkLmVtcGxveWVlSWQgJiZcbiAgICAgICAgci50aW1lc3RhbXAgPj0gdG9kYXlTdGFydCAmJlxuICAgICAgICByLnRpbWVzdGFtcCA8IHRvZGF5RW5kXG4gICAgKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBiLnRpbWVzdGFtcC5nZXRUaW1lKCkpOyAvLyBTb3J0IG9sZGVzdCBmaXJzdFxuXG5cbiAgIGlmICh0b2RheXNFbXBsb3llZVJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlY29yZCBvZiB0aGUgZGF5IGZvciB0aGlzIGVtcGxveWVlXG4gICAgIG5ld1JlY29yZC5pblRpbWUgPSBuZXdSZWNvcmQudGltZXN0YW1wO1xuICAgICBuZXdSZWNvcmQub3V0VGltZSA9IHVuZGVmaW5lZDsgLy8gRXhwbGljaXRseSBzZXQgb3V0VGltZSB0byB1bmRlZmluZWRcbiAgICAgY29uc29sZS5sb2coYFNldHRpbmcgSU4gdGltZSBmb3IgJHtuZXdSZWNvcmQuZW1wbG95ZWVJZH0gb24gJHt0b2RheVN0YXJ0LnRvRGF0ZVN0cmluZygpfTogJHtuZXdSZWNvcmQuaW5UaW1lLnRvTG9jYWxlVGltZVN0cmluZygpfWApO1xuICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzdWJzZXF1ZW50IHJlY29yZCBmb3IgdGhlIGRheVxuICAgICAgLy8gVXNlIHRoZSBJTiB0aW1lIGZyb20gdGhlIGVhcmxpZXN0IHJlY29yZCBvZiB0aGUgZGF5XG4gICAgICBuZXdSZWNvcmQuaW5UaW1lID0gdG9kYXlzRW1wbG95ZWVSZWNvcmRzWzBdLmluVGltZSB8fCB0b2RheXNFbXBsb3llZVJlY29yZHNbMF0udGltZXN0YW1wOyAvLyBGYWxsYmFjayB0byB0aW1lc3RhbXAgaWYgaW5UaW1lIG1pc3NpbmdcbiAgICAgIC8vIFRoaXMgbmV3IHJlY29yZCBiZWNvbWVzIHRoZSBsYXRlc3QgT1VUIHRpbWUgZm9yIHRoZSBkYXkgc28gZmFyXG4gICAgICBuZXdSZWNvcmQub3V0VGltZSA9IG5ld1JlY29yZC50aW1lc3RhbXA7XG4gICAgICAgY29uc29sZS5sb2coYFNldHRpbmcgT1VUIHRpbWUgZm9yICR7bmV3UmVjb3JkLmVtcGxveWVlSWR9IG9uICR7dG9kYXlTdGFydC50b0RhdGVTdHJpbmcoKX06ICR7bmV3UmVjb3JkLm91dFRpbWUudG9Mb2NhbGVUaW1lU3RyaW5nKCl9IChJbjogJHtuZXdSZWNvcmQuaW5UaW1lLnRvTG9jYWxlVGltZVN0cmluZygpfSlgKTtcblxuICAgICAgLy8gLS0tIENydWNpYWxseSwgdXBkYXRlIHRoZSBvdXRUaW1lIG9uICpwcmV2aW91cyogcmVjb3JkcyBmb3IgdGhpcyBkYXkgLS0tXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIEFkbWluIHZpZXcgc2hvd3MgdGhlIGNvcnJlY3QgbGF0ZXN0IG91dFRpbWUgZm9yIHRoZSBkYXkgb24gYWxsIHJlY29yZHMgb2YgdGhhdCBkYXlcbiAgICAgIHRvZGF5c0VtcGxveWVlUmVjb3Jkcy5mb3JFYWNoKGV4aXN0aW5nUmVjb3JkID0+IHtcbiAgICAgICAgIGlmIChleGlzdGluZ1JlY29yZC5pZCkgeyAvLyBPbmx5IHVwZGF0ZSBpZiBpdCBoYXMgYW4gSUQgKGl0IHNob3VsZClcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxsUmVjb3Jkcy5maW5kSW5kZXgociA9PiByLmlkID09PSBleGlzdGluZ1JlY29yZC5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICBhbGxSZWNvcmRzW2luZGV4XS5vdXRUaW1lID0gbmV3UmVjb3JkLm91dFRpbWU7IC8vIFVwZGF0ZSB0aGUgb3V0VGltZVxuICAgICAgICAgICAgICAgYWxsUmVjb3Jkc1tpbmRleF0uaW5UaW1lID0gbmV3UmVjb3JkLmluVGltZTsgLy8gQWxzbyB1cGRhdGUgaW5UaW1lIGZvciBjb25zaXN0ZW5jeSBvbiBvbGRlciByZWNvcmRzXG4gICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRpbmcgZXhpc3RpbmcgcmVjb3JkICR7YWxsUmVjb3Jkc1tpbmRleF0uaWR9IHdpdGggT3V0OiAke25ld1JlY29yZC5vdXRUaW1lLnRvTG9jYWxlVGltZVN0cmluZygpfSwgSW46ICR7bmV3UmVjb3JkLmluVGltZS50b0xvY2FsZVRpbWVTdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgfVxuICAvLyAtLS0gRW5kIElOL09VVCBMb2dpYyAtLS1cblxuICAvLyBBZGQgdGhlICpuZXcqIHJlY29yZCB0byB0aGUgbWFpbiBsaXN0XG4gIGFsbFJlY29yZHMudW5zaGlmdChuZXdSZWNvcmQpOyAvLyBBZGQgdG8gdGhlIGJlZ2lubmluZ1xuXG4gIC8vIEZpbHRlciBvdXQgYW55IHBvdGVudGlhbGx5IGR1cGxpY2F0ZWQgcmVjb3JkcyBiZWZvcmUgc2F2aW5nIChqdXN0IGluIGNhc2UpXG4gICBjb25zdCB1bmlxdWVSZWNvcmRzID0gQXJyYXkuZnJvbShuZXcgTWFwKGFsbFJlY29yZHMubWFwKGl0ZW0gPT4gW2l0ZW0uaWQsIGl0ZW1dKSkudmFsdWVzKCkpO1xuXG4gICAvLyBTb3J0IGFnYWluIGJlZm9yZSBzYXZpbmcgdG8gbWFpbnRhaW4gb3JkZXIgKG9wdGlvbmFsLCBidXQgZ29vZCBwcmFjdGljZSlcbiAgIHVuaXF1ZVJlY29yZHMuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKTtcblxuXG4gIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXR0ZW5kYW5jZVJlY29yZHMnLCBKU09OLnN0cmluZ2lmeSh1bmlxdWVSZWNvcmRzKSk7XG4gICAgICBjb25zb2xlLmxvZyhgQXR0ZW5kYW5jZSByZWNvcmQgc2F2ZWQ6ICR7bmV3UmVjb3JkLmlkfSwgVG90YWwgcmVjb3JkcyBub3c6ICR7dW5pcXVlUmVjb3Jkcy5sZW5ndGh9YCk7XG4gICAgICByZXR1cm4gbmV3UmVjb3JkOyAvLyBSZXR1cm4gdGhlIG5ld2x5IGNyZWF0ZWQgcmVjb3JkIHdpdGggcG90ZW50aWFsbHkgYWRkZWQgaW4vb3V0IHRpbWVzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIGF0dGVuZGFuY2UgcmVjb3JkcyB0byBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYXZlIGF0dGVuZGFuY2UgZGF0YS5cIik7IC8vIFJldGhyb3cgb3IgaGFuZGxlIGFwcHJvcHJpYXRlbHlcbiAgfVxufTtcblxuXG4vLyAtLS0gVXRpbGl0eSBGdW5jdGlvbnMgKEV4YW1wbGUpIC0tLVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIENTViBzdHJpbmcgZnJvbSBhdHRlbmRhbmNlIHJlY29yZHMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUF0dGVuZGFuY2VDc3YgPSAocmVjb3JkczogQXR0ZW5kYW5jZVJlY29yZFtdKTogc3RyaW5nID0+IHtcbiAgY29uc29sZS5sb2coYEdlbmVyYXRpbmcgQ1NWIGZvciAke3JlY29yZHMubGVuZ3RofSByZWNvcmRzLmApO1xuICBpZiAoIXJlY29yZHMgfHwgcmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAgLy8gRGVmaW5lIGhlYWRlcnMgY2FyZWZ1bGx5IC0gbWF0Y2ggdGhlIG9yZGVyIGluIHRoZSByb3dzXG4gICBjb25zdCBoZWFkZXJzID0gW1xuICAgIFwiRW1wbG95ZWUgSURcIixcbiAgICBcIlBob25lIE51bWJlclwiLFxuICAgIFwiTmFtZVwiLFxuICAgIFwiRGF0ZVwiLFxuICAgIFwiTWFya2VkIFRpbWVcIiwgLy8gUmVuYW1lZCBmcm9tIFwiVGltZVwiIGZvciBjbGFyaXR5XG4gICAgXCJJbiBUaW1lXCIsIC8vIEFkZCBJbiBUaW1lIGNvbHVtblxuICAgIFwiT3V0IFRpbWVcIiwgLy8gQWRkIE91dCBUaW1lIGNvbHVtblxuICAgIFwiU2hpZnQgVGltaW5nXCIsXG4gICAgXCJXb3JraW5nIExvY2F0aW9uXCIsXG4gICAgXCJMYXRpdHVkZVwiLFxuICAgIFwiTG9uZ2l0dWRlXCIsXG4gICAgXCJBZGRyZXNzXCIsXG4gICAgXCJDYXB0dXJlIE1ldGhvZFwiLFxuICAgIC8vIFwiUGhvdG8gRGF0YSBVUklcIiAvLyBVc3VhbGx5IHRvbyBsYXJnZSBmb3IgQ1NWLCBtYXliZSBsaW5rIG9yIG9taXRcbiAgXTtcblxuICAgLy8gRnVuY3Rpb24gdG8gZm9ybWF0IGRhdGUvdGltZSwgaGFuZGxpbmcgdW5kZWZpbmVkIG9yIGludmFsaWQgZGF0ZXNcbiAgICBjb25zdCBmb3JtYXREYXRlVGltZSA9IChkYXRlOiBEYXRlIHwgdW5kZWZpbmVkIHwgc3RyaW5nLCB0eXBlOiAnZGF0ZScgfCAndGltZScpOiBzdHJpbmcgPT4ge1xuICAgICAgICBpZiAoIWRhdGUpIHJldHVybiAnLS0nO1xuICAgICAgICBjb25zdCBkID0gZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRlIDogbmV3IERhdGUoZGF0ZSk7IC8vIEVuc3VyZSBpdCdzIGEgRGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuICdJbnZhbGlkIERhdGUnOyAvLyBDaGVjayBpZiB0aGUgZGF0ZSBpcyB2YWxpZFxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RhdGUnKSByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGltZScpIHJldHVybiBkLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuICctLSc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmb3JtYXR0aW5nIGRhdGU6XCIsIGQsIGUpO1xuICAgICAgICAgICAgcmV0dXJuICdGb3JtYXQgRXJyb3InO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEhlbHBlciB0byBlc2NhcGUgQ1NWIGZpZWxkcyBjb250YWluaW5nIGNvbW1hcyBvciBkb3VibGUgcXVvdGVzXG4gICAgY29uc3QgZXNjYXBlQ3N2RmllbGQgPSAoZmllbGQ6IHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZCk6IHN0cmluZyA9PiB7XG4gICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkIHx8IGZpZWxkID09PSBudWxsKSByZXR1cm4gJ1wiXCInO1xuICAgICAgICBjb25zdCBzdHJpbmdGaWVsZCA9IFN0cmluZyhmaWVsZCk7XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBjb250YWlucyBhIGNvbW1hLCBkb3VibGUgcXVvdGUsIG9yIG5ld2xpbmUsIGVuY2xvc2UgaW4gZG91YmxlIHF1b3RlcyBhbmQgZXNjYXBlIGV4aXN0aW5nIGRvdWJsZSBxdW90ZXNcbiAgICAgICAgaWYgKHN0cmluZ0ZpZWxkLmluY2x1ZGVzKCcsJykgfHwgc3RyaW5nRmllbGQuaW5jbHVkZXMoJ1wiJykgfHwgc3RyaW5nRmllbGQuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFwiJHtzdHJpbmdGaWVsZC5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nRmllbGQ7IC8vIFJldHVybiBhcyBpcyBpZiBubyBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICB9O1xuXG5cbiAgY29uc3QgY3N2Um93cyA9IFtcbiAgICBoZWFkZXJzLmpvaW4oJywnKSwgLy8gSGVhZGVyIHJvd1xuICAgIC4uLnJlY29yZHMubWFwKHJlY29yZCA9PiBbXG4gICAgICBlc2NhcGVDc3ZGaWVsZChyZWNvcmQuZW1wbG95ZWVJZCksXG4gICAgICBlc2NhcGVDc3ZGaWVsZChyZWNvcmQucGhvbmUpLFxuICAgICAgZXNjYXBlQ3N2RmllbGQocmVjb3JkLm5hbWUpLFxuICAgICAgZm9ybWF0RGF0ZVRpbWUocmVjb3JkLnRpbWVzdGFtcCwgJ2RhdGUnKSxcbiAgICAgIGZvcm1hdERhdGVUaW1lKHJlY29yZC50aW1lc3RhbXAsICd0aW1lJyksIC8vIE1hcmtlZCB0aW1lXG4gICAgICBmb3JtYXREYXRlVGltZShyZWNvcmQuaW5UaW1lLCAndGltZScpLCAvLyBGb3JtYXQgSU4gdGltZVxuICAgICAgZm9ybWF0RGF0ZVRpbWUocmVjb3JkLm91dFRpbWUsICd0aW1lJyksIC8vIEZvcm1hdCBPVVQgdGltZVxuICAgICAgZXNjYXBlQ3N2RmllbGQocmVjb3JkLnNoaWZ0VGltaW5nKSxcbiAgICAgIGVzY2FwZUNzdkZpZWxkKHJlY29yZC53b3JraW5nTG9jYXRpb24pLFxuICAgICAgZXNjYXBlQ3N2RmllbGQocmVjb3JkLmxhdGl0dWRlPy50b0ZpeGVkKDYpKSwgLy8gQWRkIHByZWNpc2lvbiBpZiBuZWVkZWRcbiAgICAgIGVzY2FwZUNzdkZpZWxkKHJlY29yZC5sb25naXR1ZGU/LnRvRml4ZWQoNikpLFxuICAgICAgZXNjYXBlQ3N2RmllbGQocmVjb3JkLmFkZHJlc3MpLFxuICAgICAgZXNjYXBlQ3N2RmllbGQocmVjb3JkLmNhcHR1cmVNZXRob2QpLFxuICAgIF0uam9pbignLCcpKSAvLyBKb2luIHZhbHVlcyBpbnRvIGEgQ1NWIHJvd1xuICBdO1xuXG4gIHJldHVybiBjc3ZSb3dzLmpvaW4oJ1xcbicpOyAvLyBKb2luIHJvd3Mgd2l0aCBuZXdsaW5lIGNoYXJhY3RlcnNcbn07XG4iXSwibmFtZXMiOlsiZ2V0RW1wbG95ZWVzIiwiY29uc29sZSIsImxvZyIsIndhcm4iLCJlbXBsb3llZXNKc29uIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiYWRkRW1wbG95ZWUiLCJlbXBsb3llZURhdGEiLCJFcnJvciIsImVtcGxveWVlcyIsImVtcGxveWVlSWQiLCJuYW1lIiwicGhvbmUiLCJzb21lIiwiZW1wIiwibmV3RW1wbG95ZWUiLCJpZCIsIk1hdGgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJwdXNoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInVwZGF0ZUVtcGxveWVlIiwidXBkYXRlZEVtcGxveWVlRGF0YSIsImVtcGxveWVlSW5kZXgiLCJmaW5kSW5kZXgiLCJkZWxldGVFbXBsb3llZSIsImVtcGxveWVlSW50ZXJuYWxJZCIsImluaXRpYWxMZW5ndGgiLCJsZW5ndGgiLCJmaWx0ZXIiLCJnZXRFbXBsb3llZUJ5SWQiLCJ1c2VySWQiLCJlbXBsb3llZSIsImZpbmQiLCJnZXRBdHRlbmRhbmNlUmVjb3JkcyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJ0b0lTT1N0cmluZyIsInJlY29yZHMiLCJyZWNvcmRzSnNvbiIsInBhcnNlZERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJyZWNvcmQiLCJ0aW1lc3RhbXAiLCJpblRpbWUiLCJ1bmRlZmluZWQiLCJvdXRUaW1lIiwiaXNOYU4iLCJnZXRUaW1lIiwicmVtb3ZlSXRlbSIsInJlY29yZERhdGUiLCJzdGFydCIsInNldEhvdXJzIiwiZW5kIiwiaXNBZnRlclN0YXJ0IiwiaXNCZWZvcmVFbmQiLCJzb3J0IiwiYSIsImIiLCJ0aW1lQSIsInRpbWVCIiwic2F2ZUF0dGVuZGFuY2UiLCJwaG90b0RhdGFVcmkiLCJhbGxSZWNvcmRzIiwibmV3UmVjb3JkIiwidG9kYXlTdGFydCIsInRvZGF5RW5kIiwic2V0RGF0ZSIsImdldERhdGUiLCJ0b2RheXNFbXBsb3llZVJlY29yZHMiLCJyIiwidG9EYXRlU3RyaW5nIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiZm9yRWFjaCIsImV4aXN0aW5nUmVjb3JkIiwiaW5kZXgiLCJ1bnNoaWZ0IiwidW5pcXVlUmVjb3JkcyIsImZyb20iLCJNYXAiLCJpdGVtIiwidmFsdWVzIiwiZ2VuZXJhdGVBdHRlbmRhbmNlQ3N2IiwiaGVhZGVycyIsImZvcm1hdERhdGVUaW1lIiwiZGF0ZSIsInR5cGUiLCJkIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZSIsImVzY2FwZUNzdkZpZWxkIiwiZmllbGQiLCJzdHJpbmdGaWVsZCIsIlN0cmluZyIsImluY2x1ZGVzIiwicmVwbGFjZSIsImNzdlJvd3MiLCJqb2luIiwic2hpZnRUaW1pbmciLCJ3b3JraW5nTG9jYXRpb24iLCJsYXRpdHVkZSIsInRvRml4ZWQiLCJsb25naXR1ZGUiLCJhZGRyZXNzIiwiY2FwdHVyZU1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/attendance.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/auth.ts":
/*!******************************!*\
  !*** ./src/services/auth.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authenticateUser: function() { return /* binding */ authenticateUser; },\n/* harmony export */   checkLoginStatus: function() { return /* binding */ checkLoginStatus; },\n/* harmony export */   logoutUser: function() { return /* binding */ logoutUser; },\n/* harmony export */   storeLoginSession: function() { return /* binding */ storeLoginSession; }\n/* harmony export */ });\n/* harmony import */ var _attendance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attendance */ \"(app-pages-browser)/./src/services/attendance.ts\");\n// Functions using localStorage are inherently client-side dependent.\n\n// For this example, admin password. NEVER do this in production for real credentials.\nconst ADMIN_PASSWORD = \"12345\";\n/**\n * Authenticates a user based on userId and password.\n * Checks against localStorage for employee data or admin credentials.\n * NOTE: Using localStorage makes this inherently client-side dependent.\n * If called during SSR without checks, it will fail.\n * Ensure this is only called from client components or within useEffect/event handlers.\n *\n * @param userId - The user ID (employee phone number or 'admin').\n * @param password - The password (only required for admin).\n * @returns Promise<boolean> - True if authentication is successful, false otherwise.\n */ const authenticateUser = async (userId, password)=>{\n    console.log('[AuthService] authenticateUser: Attempting for userId: \"'.concat(userId, '\"'));\n    const trimmedUserId = typeof userId === \"string\" ? userId.trim() : \"\";\n    try {\n        if (trimmedUserId.toLowerCase() === \"admin\") {\n            const isAdmin = password === ADMIN_PASSWORD;\n            console.log('[AuthService] authenticateUser: Admin login attempt. Password provided: \"'.concat(password ? \"******\" : \"undefined\", '\". Result: ').concat(isAdmin));\n            return isAdmin;\n        } else {\n            if (true) {\n                const employees = await (0,_attendance__WEBPACK_IMPORTED_MODULE_0__.getEmployees)();\n                const employeeExists = employees.some((emp)=>emp.phone === trimmedUserId);\n                console.log('[AuthService] authenticateUser: Employee login attempt for phone \"'.concat(trimmedUserId, '\". Result: ').concat(employeeExists));\n                return employeeExists;\n            } else {}\n        }\n    } catch (error) {\n        console.error(\"[AuthService] authenticateUser: Error during authentication:\", error);\n        return false;\n    }\n};\n/**\n * Checks if a user is currently logged in based on localStorage.\n * NOTE: Inherently client-side.\n * @returns string | null - The logged-in user ID (trimmed, and 'admin' is lowercased) or null if not logged in or empty.\n */ const checkLoginStatus = ()=>{\n    if (true) {\n        try {\n            const storedValue = localStorage.getItem(\"loggedInUser\");\n            console.log('[AuthService] checkLoginStatus: Value from localStorage: \"'.concat(storedValue, '\"'));\n            if (storedValue) {\n                const trimmedValue = storedValue.trim();\n                console.log('[AuthService] checkLoginStatus: Trimmed value: \"'.concat(trimmedValue, '\"'));\n                if (trimmedValue.toLowerCase() === \"admin\") {\n                    console.log('[AuthService] checkLoginStatus: Recognized as admin. Returning \"admin\".');\n                    return \"admin\";\n                }\n                if (trimmedValue !== \"\") {\n                    console.log('[AuthService] checkLoginStatus: Recognized as non-admin user. Returning \"'.concat(trimmedValue, '\".'));\n                    return trimmedValue;\n                }\n                console.log(\"[AuthService] checkLoginStatus: Value was empty after trim. Returning null.\");\n                // localStorage.removeItem('loggedInUser'); // Clear if empty after trim\n                return null;\n            }\n            console.log(\"[AuthService] checkLoginStatus: No value found in localStorage. Returning null.\");\n            return null;\n        } catch (error) {\n            console.error(\"[AuthService] checkLoginStatus: Error accessing localStorage:\", error);\n            return null;\n        }\n    }\n    console.warn(\"[AuthService] checkLoginStatus: Called on server-side. localStorage not available. Returning null.\");\n    return null;\n};\n/**\n * Logs the user out by removing the flag from localStorage.\n * NOTE: Inherently client-side.\n */ const logoutUser = ()=>{\n    if (true) {\n        try {\n            const oldValue = localStorage.getItem(\"loggedInUser\");\n            localStorage.removeItem(\"loggedInUser\");\n            console.log('[AuthService] logoutUser: User logged out. Previous localStorage value was \"'.concat(oldValue, '\".'));\n        } catch (error) {\n            console.error(\"[AuthService] logoutUser: Error removing item from localStorage during logout:\", error);\n        }\n    } else {}\n};\n/**\n * Stores the logged-in user's ID in localStorage.\n * If the user is 'admin' (case-insensitive), it's stored as lowercase 'admin'.\n * NOTE: Inherently client-side.\n * @param userId - The ID of the user to store.\n */ const storeLoginSession = (userId)=>{\n    if (true) {\n        try {\n            let valueToStore = typeof userId === \"string\" ? userId.trim() : \"\";\n            console.log('[AuthService] storeLoginSession: Original userId: \"'.concat(userId, '\", Trimmed for storage: \"').concat(valueToStore, '\"'));\n            if (valueToStore.toLowerCase() === \"admin\") {\n                valueToStore = \"admin\"; // Standardize to lowercase 'admin' for storage\n                console.log('[AuthService] storeLoginSession: User is admin, standardized to: \"'.concat(valueToStore, '\" for storage.'));\n            }\n            localStorage.setItem(\"loggedInUser\", valueToStore);\n            console.log('[AuthService] storeLoginSession: Successfully stored \"'.concat(valueToStore, '\" in localStorage for key \"loggedInUser\".'));\n        } catch (error) {\n            console.error(\"[AuthService] storeLoginSession: Error storing login session in localStorage:\", error);\n        }\n    } else {}\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hdXRoLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEscUVBQXFFO0FBR3pCO0FBRTVDLHNGQUFzRjtBQUN0RixNQUFNQyxpQkFBaUI7QUFFdkI7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1DLG1CQUFtQixPQUFPQyxRQUFnQkM7SUFDckRDLFFBQVFDLEdBQUcsQ0FBQywyREFBa0UsT0FBUEgsUUFBTztJQUU5RSxNQUFNSSxnQkFBZ0IsT0FBT0osV0FBVyxXQUFXQSxPQUFPSyxJQUFJLEtBQUs7SUFFbkUsSUFBSTtRQUNGLElBQUlELGNBQWNFLFdBQVcsT0FBTyxTQUFTO1lBQzNDLE1BQU1DLFVBQVVOLGFBQWFIO1lBQzdCSSxRQUFRQyxHQUFHLENBQUMsNEVBQTJISSxPQUEvQ04sV0FBVyxXQUFXLGFBQVksZUFBcUIsT0FBUk07WUFDdkksT0FBT0E7UUFDVCxPQUFPO1lBQ0osSUFBSSxJQUFrQixFQUFhO2dCQUNqQyxNQUFNQyxZQUFZLE1BQU1YLHlEQUFZQTtnQkFDcEMsTUFBTVksaUJBQWlCRCxVQUFVRSxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLEtBQUssS0FBS1I7Z0JBQzNERixRQUFRQyxHQUFHLENBQUMscUVBQWdHTSxPQUEzQkwsZUFBYyxlQUE0QixPQUFmSztnQkFDNUcsT0FBT0E7WUFDVCxPQUFPLEVBR047UUFDSjtJQUNGLEVBQUUsT0FBT0ssT0FBTztRQUNkWixRQUFRWSxLQUFLLENBQUMsZ0VBQWdFQTtRQUM5RSxPQUFPO0lBQ1Q7QUFDRixFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU1DLG1CQUFtQjtJQUM3QixJQUFJLElBQWtCLEVBQWE7UUFDakMsSUFBSTtZQUNGLE1BQU1DLGNBQWNDLGFBQWFDLE9BQU8sQ0FBQztZQUN6Q2hCLFFBQVFDLEdBQUcsQ0FBQyw2REFBeUUsT0FBWmEsYUFBWTtZQUVyRixJQUFJQSxhQUFhO2dCQUNmLE1BQU1HLGVBQWVILFlBQVlYLElBQUk7Z0JBQ3JDSCxRQUFRQyxHQUFHLENBQUMsbURBQWdFLE9BQWJnQixjQUFhO2dCQUU1RSxJQUFJQSxhQUFhYixXQUFXLE9BQU8sU0FBUztvQkFDMUNKLFFBQVFDLEdBQUcsQ0FBQztvQkFDWixPQUFPO2dCQUNUO2dCQUVBLElBQUlnQixpQkFBaUIsSUFBSTtvQkFDdkJqQixRQUFRQyxHQUFHLENBQUMsNEVBQXlGLE9BQWJnQixjQUFhO29CQUNyRyxPQUFPQTtnQkFDVDtnQkFDQWpCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWix3RUFBd0U7Z0JBQ3hFLE9BQU87WUFDVDtZQUNBRCxRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPO1FBQ1QsRUFBRSxPQUFPVyxPQUFPO1lBQ2RaLFFBQVFZLEtBQUssQ0FBQyxpRUFBaUVBO1lBQy9FLE9BQU87UUFDVDtJQUNGO0lBQ0FaLFFBQVFXLElBQUksQ0FBQztJQUNiLE9BQU87QUFDVixFQUFFO0FBRUY7OztDQUdDLEdBQ00sTUFBTU8sYUFBYTtJQUN0QixJQUFJLElBQWtCLEVBQWE7UUFDakMsSUFBSTtZQUNGLE1BQU1DLFdBQVdKLGFBQWFDLE9BQU8sQ0FBQztZQUN0Q0QsYUFBYUssVUFBVSxDQUFDO1lBQ3hCcEIsUUFBUUMsR0FBRyxDQUFDLCtFQUF3RixPQUFUa0IsVUFBUztRQUN0RyxFQUFFLE9BQU9QLE9BQU87WUFDYlosUUFBUVksS0FBSyxDQUFDLGtGQUFrRkE7UUFDbkc7SUFDRixPQUFPLEVBRU47QUFDTCxFQUFFO0FBRUY7Ozs7O0NBS0MsR0FDTSxNQUFNUyxvQkFBb0IsQ0FBQ3ZCO0lBQzlCLElBQUksSUFBa0IsRUFBYTtRQUNqQyxJQUFJO1lBQ0YsSUFBSXdCLGVBQWUsT0FBT3hCLFdBQVcsV0FBV0EsT0FBT0ssSUFBSSxLQUFLO1lBQ2hFSCxRQUFRQyxHQUFHLENBQUMsc0RBQXdGcUIsT0FBbEN4QixRQUFPLDZCQUF3QyxPQUFid0IsY0FBYTtZQUVqSCxJQUFJQSxhQUFhbEIsV0FBVyxPQUFPLFNBQVM7Z0JBQzFDa0IsZUFBZSxTQUFTLCtDQUErQztnQkFDdkV0QixRQUFRQyxHQUFHLENBQUMscUVBQWtGLE9BQWJxQixjQUFhO1lBQ2hHO1lBRUFQLGFBQWFRLE9BQU8sQ0FBQyxnQkFBZ0JEO1lBQ3JDdEIsUUFBUUMsR0FBRyxDQUFDLHlEQUFzRSxPQUFicUIsY0FBYTtRQUNwRixFQUFFLE9BQU9WLE9BQU87WUFDZFosUUFBUVksS0FBSyxDQUFDLGlGQUFpRkE7UUFDakc7SUFDRixPQUFPLEVBRU47QUFDTCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9hdXRoLnRzP2I4MGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnVuY3Rpb25zIHVzaW5nIGxvY2FsU3RvcmFnZSBhcmUgaW5oZXJlbnRseSBjbGllbnQtc2lkZSBkZXBlbmRlbnQuXG5cbmltcG9ydCB0eXBlIHsgRW1wbG95ZWUgfSBmcm9tICcuL2F0dGVuZGFuY2UnOyBcbmltcG9ydCB7IGdldEVtcGxveWVlcyB9IGZyb20gJy4vYXR0ZW5kYW5jZSc7XG5cbi8vIEZvciB0aGlzIGV4YW1wbGUsIGFkbWluIHBhc3N3b3JkLiBORVZFUiBkbyB0aGlzIGluIHByb2R1Y3Rpb24gZm9yIHJlYWwgY3JlZGVudGlhbHMuXG5jb25zdCBBRE1JTl9QQVNTV09SRCA9ICcxMjM0NSc7IFxuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZXMgYSB1c2VyIGJhc2VkIG9uIHVzZXJJZCBhbmQgcGFzc3dvcmQuXG4gKiBDaGVja3MgYWdhaW5zdCBsb2NhbFN0b3JhZ2UgZm9yIGVtcGxveWVlIGRhdGEgb3IgYWRtaW4gY3JlZGVudGlhbHMuXG4gKiBOT1RFOiBVc2luZyBsb2NhbFN0b3JhZ2UgbWFrZXMgdGhpcyBpbmhlcmVudGx5IGNsaWVudC1zaWRlIGRlcGVuZGVudC5cbiAqIElmIGNhbGxlZCBkdXJpbmcgU1NSIHdpdGhvdXQgY2hlY2tzLCBpdCB3aWxsIGZhaWwuXG4gKiBFbnN1cmUgdGhpcyBpcyBvbmx5IGNhbGxlZCBmcm9tIGNsaWVudCBjb21wb25lbnRzIG9yIHdpdGhpbiB1c2VFZmZlY3QvZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHVzZXJJZCAtIFRoZSB1c2VyIElEIChlbXBsb3llZSBwaG9uZSBudW1iZXIgb3IgJ2FkbWluJykuXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgKG9ubHkgcmVxdWlyZWQgZm9yIGFkbWluKS5cbiAqIEByZXR1cm5zIFByb21pc2U8Ym9vbGVhbj4gLSBUcnVlIGlmIGF1dGhlbnRpY2F0aW9uIGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGF1dGhlbnRpY2F0ZVVzZXIgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIHBhc3N3b3JkPzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gIGNvbnNvbGUubG9nKGBbQXV0aFNlcnZpY2VdIGF1dGhlbnRpY2F0ZVVzZXI6IEF0dGVtcHRpbmcgZm9yIHVzZXJJZDogXCIke3VzZXJJZH1cImApO1xuICBcbiAgY29uc3QgdHJpbW1lZFVzZXJJZCA9IHR5cGVvZiB1c2VySWQgPT09ICdzdHJpbmcnID8gdXNlcklkLnRyaW0oKSA6ICcnO1xuXG4gIHRyeSB7XG4gICAgaWYgKHRyaW1tZWRVc2VySWQudG9Mb3dlckNhc2UoKSA9PT0gJ2FkbWluJykge1xuICAgICAgY29uc3QgaXNBZG1pbiA9IHBhc3N3b3JkID09PSBBRE1JTl9QQVNTV09SRDtcbiAgICAgIGNvbnNvbGUubG9nKGBbQXV0aFNlcnZpY2VdIGF1dGhlbnRpY2F0ZVVzZXI6IEFkbWluIGxvZ2luIGF0dGVtcHQuIFBhc3N3b3JkIHByb3ZpZGVkOiBcIiR7cGFzc3dvcmQgPyAnKioqKioqJyA6ICd1bmRlZmluZWQnfVwiLiBSZXN1bHQ6ICR7aXNBZG1pbn1gKTtcbiAgICAgIHJldHVybiBpc0FkbWluO1xuICAgIH0gZWxzZSB7XG4gICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICBjb25zdCBlbXBsb3llZXMgPSBhd2FpdCBnZXRFbXBsb3llZXMoKTsgXG4gICAgICAgICBjb25zdCBlbXBsb3llZUV4aXN0cyA9IGVtcGxveWVlcy5zb21lKGVtcCA9PiBlbXAucGhvbmUgPT09IHRyaW1tZWRVc2VySWQpO1xuICAgICAgICAgY29uc29sZS5sb2coYFtBdXRoU2VydmljZV0gYXV0aGVudGljYXRlVXNlcjogRW1wbG95ZWUgbG9naW4gYXR0ZW1wdCBmb3IgcGhvbmUgXCIke3RyaW1tZWRVc2VySWR9XCIuIFJlc3VsdDogJHtlbXBsb3llZUV4aXN0c31gKTtcbiAgICAgICAgIHJldHVybiBlbXBsb3llZUV4aXN0cztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0F1dGhTZXJ2aWNlXSBhdXRoZW50aWNhdGVVc2VyOiBDYWxsZWQgb24gc2VydmVyLXNpZGUgZm9yIG5vbi1hZG1pbi4gbG9jYWxTdG9yYWdlIG5lZWRlZC4gUmV0dXJuaW5nIGZhbHNlLicpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tBdXRoU2VydmljZV0gYXV0aGVudGljYXRlVXNlcjogRXJyb3IgZHVyaW5nIGF1dGhlbnRpY2F0aW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdXNlciBpcyBjdXJyZW50bHkgbG9nZ2VkIGluIGJhc2VkIG9uIGxvY2FsU3RvcmFnZS5cbiAqIE5PVEU6IEluaGVyZW50bHkgY2xpZW50LXNpZGUuXG4gKiBAcmV0dXJucyBzdHJpbmcgfCBudWxsIC0gVGhlIGxvZ2dlZC1pbiB1c2VyIElEICh0cmltbWVkLCBhbmQgJ2FkbWluJyBpcyBsb3dlcmNhc2VkKSBvciBudWxsIGlmIG5vdCBsb2dnZWQgaW4gb3IgZW1wdHkuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0xvZ2luU3RhdHVzID0gKCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgIHRyeSB7XG4gICAgICAgY29uc3Qgc3RvcmVkVmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbG9nZ2VkSW5Vc2VyJyk7XG4gICAgICAgY29uc29sZS5sb2coYFtBdXRoU2VydmljZV0gY2hlY2tMb2dpblN0YXR1czogVmFsdWUgZnJvbSBsb2NhbFN0b3JhZ2U6IFwiJHtzdG9yZWRWYWx1ZX1cImApO1xuXG4gICAgICAgaWYgKHN0b3JlZFZhbHVlKSB7XG4gICAgICAgICBjb25zdCB0cmltbWVkVmFsdWUgPSBzdG9yZWRWYWx1ZS50cmltKCk7XG4gICAgICAgICBjb25zb2xlLmxvZyhgW0F1dGhTZXJ2aWNlXSBjaGVja0xvZ2luU3RhdHVzOiBUcmltbWVkIHZhbHVlOiBcIiR7dHJpbW1lZFZhbHVlfVwiYCk7XG5cbiAgICAgICAgIGlmICh0cmltbWVkVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2FkbWluJykge1xuICAgICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhTZXJ2aWNlXSBjaGVja0xvZ2luU3RhdHVzOiBSZWNvZ25pemVkIGFzIGFkbWluLiBSZXR1cm5pbmcgXCJhZG1pblwiLicpO1xuICAgICAgICAgICByZXR1cm4gJ2FkbWluJztcbiAgICAgICAgIH1cbiAgICAgICAgIFxuICAgICAgICAgaWYgKHRyaW1tZWRWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgY29uc29sZS5sb2coYFtBdXRoU2VydmljZV0gY2hlY2tMb2dpblN0YXR1czogUmVjb2duaXplZCBhcyBub24tYWRtaW4gdXNlci4gUmV0dXJuaW5nIFwiJHt0cmltbWVkVmFsdWV9XCIuYCk7XG4gICAgICAgICAgIHJldHVybiB0cmltbWVkVmFsdWU7XG4gICAgICAgICB9XG4gICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhTZXJ2aWNlXSBjaGVja0xvZ2luU3RhdHVzOiBWYWx1ZSB3YXMgZW1wdHkgYWZ0ZXIgdHJpbS4gUmV0dXJuaW5nIG51bGwuJyk7XG4gICAgICAgICAvLyBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnbG9nZ2VkSW5Vc2VyJyk7IC8vIENsZWFyIGlmIGVtcHR5IGFmdGVyIHRyaW1cbiAgICAgICAgIHJldHVybiBudWxsOyBcbiAgICAgICB9XG4gICAgICAgY29uc29sZS5sb2coJ1tBdXRoU2VydmljZV0gY2hlY2tMb2dpblN0YXR1czogTm8gdmFsdWUgZm91bmQgaW4gbG9jYWxTdG9yYWdlLiBSZXR1cm5pbmcgbnVsbC4nKTtcbiAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICBjb25zb2xlLmVycm9yKCdbQXV0aFNlcnZpY2VdIGNoZWNrTG9naW5TdGF0dXM6IEVycm9yIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgIHJldHVybiBudWxsO1xuICAgICB9XG4gICB9XG4gICBjb25zb2xlLndhcm4oJ1tBdXRoU2VydmljZV0gY2hlY2tMb2dpblN0YXR1czogQ2FsbGVkIG9uIHNlcnZlci1zaWRlLiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4gUmV0dXJuaW5nIG51bGwuJyk7XG4gICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogTG9ncyB0aGUgdXNlciBvdXQgYnkgcmVtb3ZpbmcgdGhlIGZsYWcgZnJvbSBsb2NhbFN0b3JhZ2UuXG4gKiBOT1RFOiBJbmhlcmVudGx5IGNsaWVudC1zaWRlLlxuICovXG5leHBvcnQgY29uc3QgbG9nb3V0VXNlciA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xvZ2dlZEluVXNlcicpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnbG9nZ2VkSW5Vc2VyJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbQXV0aFNlcnZpY2VdIGxvZ291dFVzZXI6IFVzZXIgbG9nZ2VkIG91dC4gUHJldmlvdXMgbG9jYWxTdG9yYWdlIHZhbHVlIHdhcyBcIiR7b2xkVmFsdWV9XCIuYCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgY29uc29sZS5lcnJvcignW0F1dGhTZXJ2aWNlXSBsb2dvdXRVc2VyOiBFcnJvciByZW1vdmluZyBpdGVtIGZyb20gbG9jYWxTdG9yYWdlIGR1cmluZyBsb2dvdXQ6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tBdXRoU2VydmljZV0gbG9nb3V0VXNlcjogQ2FsbGVkIG9uIHNlcnZlci1zaWRlLiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0b3JlcyB0aGUgbG9nZ2VkLWluIHVzZXIncyBJRCBpbiBsb2NhbFN0b3JhZ2UuXG4gKiBJZiB0aGUgdXNlciBpcyAnYWRtaW4nIChjYXNlLWluc2Vuc2l0aXZlKSwgaXQncyBzdG9yZWQgYXMgbG93ZXJjYXNlICdhZG1pbicuXG4gKiBOT1RFOiBJbmhlcmVudGx5IGNsaWVudC1zaWRlLlxuICogQHBhcmFtIHVzZXJJZCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byBzdG9yZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0b3JlTG9naW5TZXNzaW9uID0gKHVzZXJJZDogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdmFsdWVUb1N0b3JlID0gdHlwZW9mIHVzZXJJZCA9PT0gJ3N0cmluZycgPyB1c2VySWQudHJpbSgpIDogJyc7IFxuICAgICAgICBjb25zb2xlLmxvZyhgW0F1dGhTZXJ2aWNlXSBzdG9yZUxvZ2luU2Vzc2lvbjogT3JpZ2luYWwgdXNlcklkOiBcIiR7dXNlcklkfVwiLCBUcmltbWVkIGZvciBzdG9yYWdlOiBcIiR7dmFsdWVUb1N0b3JlfVwiYCk7XG5cbiAgICAgICAgaWYgKHZhbHVlVG9TdG9yZS50b0xvd2VyQ2FzZSgpID09PSAnYWRtaW4nKSB7XG4gICAgICAgICAgdmFsdWVUb1N0b3JlID0gJ2FkbWluJzsgLy8gU3RhbmRhcmRpemUgdG8gbG93ZXJjYXNlICdhZG1pbicgZm9yIHN0b3JhZ2VcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0F1dGhTZXJ2aWNlXSBzdG9yZUxvZ2luU2Vzc2lvbjogVXNlciBpcyBhZG1pbiwgc3RhbmRhcmRpemVkIHRvOiBcIiR7dmFsdWVUb1N0b3JlfVwiIGZvciBzdG9yYWdlLmApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbG9nZ2VkSW5Vc2VyJywgdmFsdWVUb1N0b3JlKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtBdXRoU2VydmljZV0gc3RvcmVMb2dpblNlc3Npb246IFN1Y2Nlc3NmdWxseSBzdG9yZWQgXCIke3ZhbHVlVG9TdG9yZX1cIiBpbiBsb2NhbFN0b3JhZ2UgZm9yIGtleSBcImxvZ2dlZEluVXNlclwiLmApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0F1dGhTZXJ2aWNlXSBzdG9yZUxvZ2luU2Vzc2lvbjogRXJyb3Igc3RvcmluZyBsb2dpbiBzZXNzaW9uIGluIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignW0F1dGhTZXJ2aWNlXSBzdG9yZUxvZ2luU2Vzc2lvbjogQ2FsbGVkIG9uIHNlcnZlci1zaWRlLiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbImdldEVtcGxveWVlcyIsIkFETUlOX1BBU1NXT1JEIiwiYXV0aGVudGljYXRlVXNlciIsInVzZXJJZCIsInBhc3N3b3JkIiwiY29uc29sZSIsImxvZyIsInRyaW1tZWRVc2VySWQiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJpc0FkbWluIiwiZW1wbG95ZWVzIiwiZW1wbG95ZWVFeGlzdHMiLCJzb21lIiwiZW1wIiwicGhvbmUiLCJ3YXJuIiwiZXJyb3IiLCJjaGVja0xvZ2luU3RhdHVzIiwic3RvcmVkVmFsdWUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidHJpbW1lZFZhbHVlIiwibG9nb3V0VXNlciIsIm9sZFZhbHVlIiwicmVtb3ZlSXRlbSIsInN0b3JlTG9naW5TZXNzaW9uIiwidmFsdWVUb1N0b3JlIiwic2V0SXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/auth.ts\n"));

/***/ })

});